{"version":3,"sources":["skylark-tether-all.js"],"names":["define","obj1","path","obj2","split","length","ns","i","name","_attach","skylark","attach","obj","main","isFunction","value","isNumber","isObject","isString","isUndefined","undefined","typecheck","addClass","el","forEach","cls","trim","classList","add","removeClass","remove","getClass","key","classes","classPrefix","updateClasses","all","indexOf","contains","deferred","defer","fn","push","flush","pop","_scrollBarSize","extend","out","args","Array","prototype","apply","arguments","slice","hasOwnProperty","call","uniqueId","id","getScrollBarSize","inner","document","createElement","style","width","height","outer","position","top","left","pointerEvents","visibility","overflow","appendChild","body","widthContained","offsetWidth","widthScroll","clientWidth","removeChild","general","zeroPosCache","zeroElement","getBounds","doc","documentElement","ownerDocument","docEl","box","_getActualBoundingClientRect","origin","node","setAttribute","getAttribute","_getOrigin","scrollWidth","right","scrollHeight","bottom","clientTop","clientLeft","clientHeight","boundingRect","getBoundingClientRect","rect","k","frameElement","defaultView","frameRect","err","getScrollHandleBounds","target","bounds","targetScrollTop","scrollTop","targetIsBody","pageXOffset","pageYOffset","innerHeight","innerWidth","getComputedStyle","scrollBottom","overflowX","parseFloat","borderTopWidth","borderBottomWidth","borderLeftWidth","fitAdj","Math","pow","max","scrollPercentage","getVisibleBounds","min","removeUtilElements","_classes","[object Object]","this","cache","element","targetPos","getTargetBounds","abutted","side","targetPosSide","options","addTargetClasses","BOUNDS_FORMAT","getBoundingRect","tether","to","scrollParents","nodeType","size","pos","win","toUpperCase","substr","targetAttachment","constraints","bodyElement","lastSize","targetSize","targetHeight","targetWidth","allClasses","constraint","outOfBoundsClass","pinnedClass","_getAllClasses","addClasses","tAttachment","eAttachment","attachment","changeAttachX","changeAttachY","pin","_flipYTogether","_flipXTogether","map","p","pinned","oob","_calculateOOBAndPinnedLeft","_calculateOOBAndPinnedTop","oobClass","_addOutOfBoundsClass","updateAttachClasses","trigger","shift","shiftTop","shiftLeft","Evented","event","handler","ctx","once","bindings","on","binding","index","splice","context","MIRROR_LR","center","MIRROR_TB","middle","OFFSET_MAP","addOffset","offsets","attachmentToOffset","autoToFixedAttachment","relativeToAttachment","offsetToPx","offset","parseTopLeft","getScrollParents","computedStyle","parents","parent","parentNode","overflowY","test","getOffsetParent","offsetParent","Abutment","Constraint","Shift","evented","_offset","TetherBase","modules","isFullscreenElement","e","d","fe","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","within","a","b","diff","transformKey","transforms","tethers","now","performance","lastCall","lastDuration","pendingTimeout","tick","setTimeout","clearTimeout","window","addEventListener","TetherClass","super","bind","history","setOptions","module","initialize","defaults","targetOffset","targetModifier","querySelector","Error","jquery","_addClasses","disable","enabled","enable","_cache","getter","removeEventListener","_removeClasses","elementAttach","targetAttach","_addAttachClasses","flushChanges","clearCache","elementPos","manualOffset","manualTargetOffset","scrollbarSize","ret","next","page","viewport","parentElement","optimizations","moveElement","offsetPosition","offsetParentStyle","offsetParentSize","offsetBorder","toLowerCase","scrollLeft","move","unshift","same","type","found","point","css","transcribe","_same","_pos","hasOptimizations","gpu","yPos","xPos","devicePixelRatio","round","allowPositionFixed","moved","offsetParentIsBody","currentNode","tagName","writeCSS","write","val","elVal","className","Tether","markers","dot"],"mappings":"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","file":"../skylark-tether-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        return ns[name] = obj2;\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-langx/skylark',[\r\n    \"skylark-langx-ns\"\r\n], function(ns) {\r\n\treturn ns;\r\n});\r\n\ndefine('skylark-tether/utils/type-check',[],function () {\n    'use strict';\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    function isNumber(value) {\n        return typeof value === 'number';\n    }\n    function isObject(value) {\n        return typeof value === 'object';\n    }\n    function isString(value) {\n        return typeof value === 'string';\n    }\n    function isUndefined(value) {\n        return value === undefined;\n    }\n    return {\n        isFunction: isFunction,\n        isNumber: isNumber,\n        isObject: isObject,\n        isString: isString,\n        isUndefined: isUndefined\n    };\n});\ndefine('skylark-tether/utils/classes',['./type-check'], function (typecheck) {\n    'use strict';\n    function addClass(el, name) {\n        name.split(' ').forEach(cls => {\n            if (cls.trim()) {\n                el.classList.add(cls);\n            }\n        });\n    }\n    function getClass(key = '', classes, classPrefix) {\n        if (!typecheck.isUndefined(classes) && !typecheck.isUndefined(classes[key])) {\n            if (classes[key] === false) {\n                return '';\n            }\n            return classes[key];\n        } else if (classPrefix) {\n            return `${ classPrefix }-${ key }`;\n        } else {\n            return key;\n        }\n    }\n    function removeClass(el, name) {\n        name.split(' ').forEach(cls => {\n            if (cls.trim()) {\n                el.classList.remove(cls);\n            }\n        });\n    }\n    function updateClasses(el, add, all) {\n        all.forEach(cls => {\n            if (add.indexOf(cls) === -1 && el.classList.contains(cls)) {\n                removeClass(el, cls);\n            }\n        });\n        add.forEach(cls => {\n            if (!el.classList.contains(cls)) {\n                addClass(el, cls);\n            }\n        });\n    }\n    return {\n        addClass: addClass,\n        getClass: getClass,\n        removeClass: removeClass,\n        updateClasses: updateClasses\n    };\n});\ndefine('skylark-tether/utils/deferred',[],function () {\n    'use strict';\n    const deferred = [];\n    function defer(fn) {\n        deferred.push(fn);\n    }\n    function flush() {\n        let fn;\n        while (fn = deferred.pop()) {\n            fn();\n        }\n    }\n    return {\n        defer: defer,\n        flush: flush\n    };\n});\ndefine('skylark-tether/utils/general',[],function () {\n    'use strict';\n    let _scrollBarSize = null;\n    function extend(out = {}) {\n        const args = [];\n        Array.prototype.push.apply(args, arguments);\n        args.slice(1).forEach(obj => {\n            if (obj) {\n                for (let key in obj) {\n                    if ({}.hasOwnProperty.call(obj, key)) {\n                        out[key] = obj[key];\n                    }\n                }\n            }\n        });\n        return out;\n    }\n    function getScrollBarSize() {\n        if (_scrollBarSize) {\n            return _scrollBarSize;\n        }\n        const inner = document.createElement('div');\n        inner.style.width = '100%';\n        inner.style.height = '200px';\n        const outer = document.createElement('div');\n        extend(outer.style, {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            pointerEvents: 'none',\n            visibility: 'hidden',\n            width: '200px',\n            height: '150px',\n            overflow: 'hidden'\n        });\n        outer.appendChild(inner);\n        document.body.appendChild(outer);\n        const widthContained = inner.offsetWidth;\n        outer.style.overflow = 'scroll';\n        let widthScroll = inner.offsetWidth;\n        if (widthContained === widthScroll) {\n            widthScroll = outer.clientWidth;\n        }\n        document.body.removeChild(outer);\n        const width = widthContained - widthScroll;\n        _scrollBarSize = {\n            width,\n            height: width\n        };\n        return _scrollBarSize;\n    }\n    const uniqueId = (() => {\n        let id = 0;\n        return () => ++id;\n    })();\n    return {\n        extend: extend,\n        getScrollBarSize: getScrollBarSize,\n        uniqueId: uniqueId\n    };\n});\ndefine('skylark-tether/utils/bounds',[\n    './deferred',\n    './general',\n    './type-check'\n], function (deferred, general, typecheck) {\n    'use strict';\n    const zeroPosCache = {};\n    let zeroElement = null;\n    function getBounds(body, el) {\n        let doc;\n        if (el === document) {\n            doc = document;\n            el = document.documentElement;\n        } else {\n            doc = el.ownerDocument;\n        }\n        const docEl = doc.documentElement;\n        const box = _getActualBoundingClientRect(el);\n        const origin = _getOrigin(body);\n        box.top -= origin.top;\n        box.left -= origin.left;\n        if (typecheck.isUndefined(box.width)) {\n            box.width = document.body.scrollWidth - box.left - box.right;\n        }\n        if (typecheck.isUndefined(box.height)) {\n            box.height = document.body.scrollHeight - box.top - box.bottom;\n        }\n        box.top = box.top - docEl.clientTop;\n        box.left = box.left - docEl.clientLeft;\n        box.right = doc.body.clientWidth - box.width - box.left;\n        box.bottom = doc.body.clientHeight - box.height - box.top;\n        return box;\n    }\n    function getScrollHandleBounds(body, target) {\n        let bounds;\n        const targetScrollTop = target.scrollTop;\n        const targetIsBody = target === document.body;\n        if (targetIsBody) {\n            target = document.documentElement;\n            bounds = {\n                left: pageXOffset,\n                top: pageYOffset,\n                height: innerHeight,\n                width: innerWidth\n            };\n        } else {\n            bounds = getBounds(body, target);\n        }\n        const style = getComputedStyle(target);\n        const hasBottomScroll = target.scrollWidth > target.clientWidth || [\n            style.overflow,\n            style.overflowX\n        ].indexOf('scroll') >= 0 || !targetIsBody;\n        let scrollBottom = 0;\n        if (hasBottomScroll) {\n            scrollBottom = 15;\n        }\n        const height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n        const out = {\n            width: 15,\n            height: height * 0.975 * (height / target.scrollHeight),\n            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n        };\n        let fitAdj = 0;\n        if (height < 408 && targetIsBody) {\n            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n        }\n        if (!targetIsBody) {\n            out.height = Math.max(out.height, 24);\n        }\n        const scrollPercentage = targetScrollTop / (target.scrollHeight - height);\n        out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n        if (targetIsBody) {\n            out.height = Math.max(out.height, 24);\n        }\n        return out;\n    }\n    function getVisibleBounds(body, target) {\n        if (target === document.body) {\n            return {\n                top: pageYOffset,\n                left: pageXOffset,\n                height: innerHeight,\n                width: innerWidth\n            };\n        } else {\n            const bounds = getBounds(body, target);\n            const out = {\n                height: bounds.height,\n                width: bounds.width,\n                top: bounds.top,\n                left: bounds.left\n            };\n            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\n            out.height = Math.min(innerHeight, out.height);\n            out.height -= 2;\n            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\n            out.width = Math.min(innerWidth, out.width);\n            out.width -= 2;\n            if (out.top < pageYOffset) {\n                out.top = pageYOffset;\n            }\n            if (out.left < pageXOffset) {\n                out.left = pageXOffset;\n            }\n            return out;\n        }\n    }\n    function removeUtilElements(body) {\n        if (zeroElement) {\n            body.removeChild(zeroElement);\n        }\n        zeroElement = null;\n    }\n    function _getActualBoundingClientRect(node) {\n        let boundingRect = node.getBoundingClientRect();\n        let rect = {};\n        for (let k in boundingRect) {\n            rect[k] = boundingRect[k];\n        }\n        try {\n            if (node.ownerDocument !== document) {\n                let {frameElement} = node.ownerDocument.defaultView;\n                if (frameElement) {\n                    let frameRect = _getActualBoundingClientRect(frameElement);\n                    rect.top += frameRect.top;\n                    rect.bottom += frameRect.top;\n                    rect.left += frameRect.left;\n                    rect.right += frameRect.left;\n                }\n            }\n        } catch (err) {\n        }\n        return rect;\n    }\n    function _getOrigin(body) {\n        let node = zeroElement;\n        if (!node || !body.contains(node)) {\n            node = document.createElement('div');\n            node.setAttribute('data-tether-id', general.uniqueId());\n            general.extend(node.style, {\n                top: 0,\n                left: 0,\n                position: 'absolute'\n            });\n            body.appendChild(node);\n            zeroElement = node;\n        }\n        const id = node.getAttribute('data-tether-id');\n        if (typecheck.isUndefined(zeroPosCache[id])) {\n            zeroPosCache[id] = _getActualBoundingClientRect(node);\n            deferred.defer(() => {\n                delete zeroPosCache[id];\n            });\n        }\n        return zeroPosCache[id];\n    }\n    return {\n        getBounds: getBounds,\n        getScrollHandleBounds: getScrollHandleBounds,\n        getVisibleBounds: getVisibleBounds,\n        removeUtilElements: removeUtilElements\n    };\n});\ndefine('skylark-tether/abutment',[\n    './utils/classes',\n    './utils/deferred',\n    './utils/bounds'\n], function (_classes, deferred, bounds) {\n    'use strict';\n    return {\n        position({top, left}) {\n            const {height, width} = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.element);\n            });\n            const targetPos = this.getTargetBounds();\n            const bottom = top + height;\n            const right = left + width;\n            const abutted = [];\n            if (top <= targetPos.bottom && bottom >= targetPos.top) {\n                [\n                    'left',\n                    'right'\n                ].forEach(side => {\n                    const targetPosSide = targetPos[side];\n                    if (targetPosSide === left || targetPosSide === right) {\n                        abutted.push(side);\n                    }\n                });\n            }\n            if (left <= targetPos.right && right >= targetPos.left) {\n                [\n                    'top',\n                    'bottom'\n                ].forEach(side => {\n                    const targetPosSide = targetPos[side];\n                    if (targetPosSide === top || targetPosSide === bottom) {\n                        abutted.push(side);\n                    }\n                });\n            }\n            const sides = [\n                'left',\n                'top',\n                'right',\n                'bottom'\n            ];\n            const {classes, classPrefix} = this.options;\n            this.all.push(_classes.getClass('abutted', classes, classPrefix));\n            sides.forEach(side => {\n                this.all.push(`${ _classes.getClass('abutted', classes, classPrefix) }-${ side }`);\n            });\n            if (abutted.length) {\n                this.add.push(_classes.getClass('abutted', classes, classPrefix));\n            }\n            abutted.forEach(side => {\n                this.add.push(`${ _classes.getClass('abutted', classes, classPrefix) }-${ side }`);\n            });\n            deferred.defer(() => {\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, this.add, this.all);\n                }\n                _classes.updateClasses(this.element, this.add, this.all);\n            });\n            return true;\n        }\n    };\n});\ndefine('skylark-tether/constraint',[\n    './utils/classes',\n    './utils/deferred',\n    './utils/general',\n    './utils/bounds',\n    './utils/type-check'\n], function (_classes, deferred, general, bounds, typecheck) {\n    'use strict';\n    const BOUNDS_FORMAT = [\n        'left',\n        'top',\n        'right',\n        'bottom'\n    ];\n    function getBoundingRect(body, tether, to) {\n        if (!to) {\n            return null;\n        }\n        if (to === 'scrollParent') {\n            to = tether.scrollParents[0];\n        } else if (to === 'window') {\n            to = [\n                pageXOffset,\n                pageYOffset,\n                innerWidth + pageXOffset,\n                innerHeight + pageYOffset\n            ];\n        }\n        if (to === document) {\n            to = to.documentElement;\n        }\n        if (!typecheck.isUndefined(to.nodeType)) {\n            const node = to;\n            const size = bounds.getBounds(body, to);\n            const pos = size;\n            const style = getComputedStyle(to);\n            to = [\n                pos.left,\n                pos.top,\n                size.width + pos.left,\n                size.height + pos.top\n            ];\n            if (node.ownerDocument !== document) {\n                let win = node.ownerDocument.defaultView;\n                to[0] += win.pageXOffset;\n                to[1] += win.pageYOffset;\n                to[2] += win.pageXOffset;\n                to[3] += win.pageYOffset;\n            }\n            BOUNDS_FORMAT.forEach((side, i) => {\n                side = side[0].toUpperCase() + side.substr(1);\n                if (side === 'Top' || side === 'Left') {\n                    to[i] += parseFloat(style[`border${ side }Width`]);\n                } else {\n                    to[i] -= parseFloat(style[`border${ side }Width`]);\n                }\n            });\n        }\n        return to;\n    }\n    function _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, outOfBoundsClass) {\n        if (oob.length) {\n            let oobClass;\n            if (!typecheck.isUndefined(outOfBoundsClass)) {\n                oobClass = outOfBoundsClass;\n            } else {\n                oobClass = _classes.getClass('out-of-bounds', classes, classPrefix);\n            }\n            addClasses.push(oobClass);\n            oob.forEach(side => {\n                addClasses.push(`${ oobClass }-${ side }`);\n            });\n        }\n    }\n    function _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob) {\n        if (left < bounds[0]) {\n            if (pin.indexOf('left') >= 0) {\n                left = bounds[0];\n                pinned.push('left');\n            } else {\n                oob.push('left');\n            }\n        }\n        if (left + width > bounds[2]) {\n            if (pin.indexOf('right') >= 0) {\n                left = bounds[2] - width;\n                pinned.push('right');\n            } else {\n                oob.push('right');\n            }\n        }\n        return left;\n    }\n    function _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob) {\n        if (top < bounds[1]) {\n            if (pin.indexOf('top') >= 0) {\n                top = bounds[1];\n                pinned.push('top');\n            } else {\n                oob.push('top');\n            }\n        }\n        if (top + height > bounds[3]) {\n            if (pin.indexOf('bottom') >= 0) {\n                top = bounds[3] - height;\n                pinned.push('bottom');\n            } else {\n                oob.push('bottom');\n            }\n        }\n        return top;\n    }\n    function _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left) {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n            if (eAttachment.left === 'right') {\n                left += targetWidth;\n                tAttachment.left = 'right';\n                left += width;\n                eAttachment.left = 'left';\n            } else if (eAttachment.left === 'left') {\n                left += targetWidth;\n                tAttachment.left = 'right';\n                left -= width;\n                eAttachment.left = 'right';\n            }\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n            if (eAttachment.left === 'left') {\n                left -= targetWidth;\n                tAttachment.left = 'left';\n                left -= width;\n                eAttachment.left = 'right';\n            } else if (eAttachment.left === 'right') {\n                left -= targetWidth;\n                tAttachment.left = 'left';\n                left += width;\n                eAttachment.left = 'left';\n            }\n        } else if (tAttachment.left === 'center') {\n            if (left + width > bounds[2] && eAttachment.left === 'left') {\n                left -= width;\n                eAttachment.left = 'right';\n            } else if (left < bounds[0] && eAttachment.left === 'right') {\n                left += width;\n                eAttachment.left = 'left';\n            }\n        }\n        return left;\n    }\n    function _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top) {\n        if (tAttachment.top === 'top') {\n            if (eAttachment.top === 'bottom' && top < bounds[1]) {\n                top += targetHeight;\n                tAttachment.top = 'bottom';\n                top += height;\n                eAttachment.top = 'top';\n            } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n                top -= height - targetHeight;\n                tAttachment.top = 'bottom';\n                eAttachment.top = 'bottom';\n            }\n        }\n        if (tAttachment.top === 'bottom') {\n            if (eAttachment.top === 'top' && top + height > bounds[3]) {\n                top -= targetHeight;\n                tAttachment.top = 'top';\n                top -= height;\n                eAttachment.top = 'bottom';\n            } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n                top += height - targetHeight;\n                tAttachment.top = 'top';\n                eAttachment.top = 'top';\n            }\n        }\n        if (tAttachment.top === 'middle') {\n            if (top + height > bounds[3] && eAttachment.top === 'top') {\n                top -= height;\n                eAttachment.top = 'bottom';\n            } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n                top += height;\n                eAttachment.top = 'top';\n            }\n        }\n        return top;\n    }\n    function _getAllClasses(classes, classPrefix, constraints) {\n        const allClasses = [\n            _classes.getClass('pinned', classes, classPrefix),\n            _classes.getClass('out-of-bounds', classes, classPrefix)\n        ];\n        constraints.forEach(constraint => {\n            const {outOfBoundsClass, pinnedClass} = constraint;\n            if (outOfBoundsClass) {\n                allClasses.push(outOfBoundsClass);\n            }\n            if (pinnedClass) {\n                allClasses.push(pinnedClass);\n            }\n        });\n        allClasses.forEach(cls => {\n            [\n                'left',\n                'top',\n                'right',\n                'bottom'\n            ].forEach(side => {\n                allClasses.push(`${ cls }-${ side }`);\n            });\n        });\n        return allClasses;\n    }\n    return {\n        position({top, left, targetAttachment}) {\n            if (!this.options.constraints) {\n                return true;\n            }\n            let {height, width} = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.bodyElement, this.element);\n            });\n            if (width === 0 && height === 0 && !typecheck.isUndefined(this.lastSize)) {\n                ({width, height} = this.lastSize);\n            }\n            const targetSize = this.cache('target-bounds', () => {\n                return this.getTargetBounds();\n            });\n            const {\n                height: targetHeight,\n                width: targetWidth\n            } = targetSize;\n            const {classes, classPrefix} = this.options;\n            const allClasses = _getAllClasses(classes, classPrefix, this.options.constraints);\n            const addClasses = [];\n            const tAttachment = general.extend({}, targetAttachment);\n            const eAttachment = general.extend({}, this.attachment);\n            this.options.constraints.forEach(constraint => {\n                let {to, attachment, pin} = constraint;\n                if (typecheck.isUndefined(attachment)) {\n                    attachment = '';\n                }\n                let changeAttachX, changeAttachY;\n                if (attachment.indexOf(' ') >= 0) {\n                    [changeAttachY, changeAttachX] = attachment.split(' ');\n                } else {\n                    changeAttachX = changeAttachY = attachment;\n                }\n                const bounds = getBoundingRect(this.bodyElement, this, to);\n                if (changeAttachY === 'target' || changeAttachY === 'both') {\n                    if (top < bounds[1] && tAttachment.top === 'top') {\n                        top += targetHeight;\n                        tAttachment.top = 'bottom';\n                    }\n                    if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n                        top -= targetHeight;\n                        tAttachment.top = 'top';\n                    }\n                }\n                if (changeAttachY === 'together') {\n                    top = _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top);\n                }\n                if (changeAttachX === 'target' || changeAttachX === 'both') {\n                    if (left < bounds[0] && tAttachment.left === 'left') {\n                        left += targetWidth;\n                        tAttachment.left = 'right';\n                    }\n                    if (left + width > bounds[2] && tAttachment.left === 'right') {\n                        left -= targetWidth;\n                        tAttachment.left = 'left';\n                    }\n                }\n                if (changeAttachX === 'together') {\n                    left = _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left);\n                }\n                if (changeAttachY === 'element' || changeAttachY === 'both') {\n                    if (top < bounds[1] && eAttachment.top === 'bottom') {\n                        top += height;\n                        eAttachment.top = 'top';\n                    }\n                    if (top + height > bounds[3] && eAttachment.top === 'top') {\n                        top -= height;\n                        eAttachment.top = 'bottom';\n                    }\n                }\n                if (changeAttachX === 'element' || changeAttachX === 'both') {\n                    if (left < bounds[0]) {\n                        if (eAttachment.left === 'right') {\n                            left += width;\n                            eAttachment.left = 'left';\n                        } else if (eAttachment.left === 'center') {\n                            left += width / 2;\n                            eAttachment.left = 'left';\n                        }\n                    }\n                    if (left + width > bounds[2]) {\n                        if (eAttachment.left === 'left') {\n                            left -= width;\n                            eAttachment.left = 'right';\n                        } else if (eAttachment.left === 'center') {\n                            left -= width / 2;\n                            eAttachment.left = 'right';\n                        }\n                    }\n                }\n                if (typecheck.isString(pin)) {\n                    pin = pin.split(',').map(p => p.trim());\n                } else if (pin === true) {\n                    pin = [\n                        'top',\n                        'left',\n                        'right',\n                        'bottom'\n                    ];\n                }\n                pin = pin || [];\n                const pinned = [];\n                const oob = [];\n                left = _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob);\n                top = _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob);\n                if (pinned.length) {\n                    let pinnedClass;\n                    if (!typecheck.isUndefined(this.options.pinnedClass)) {\n                        pinnedClass = this.options.pinnedClass;\n                    } else {\n                        pinnedClass = _classes.getClass('pinned', classes, classPrefix);\n                    }\n                    addClasses.push(pinnedClass);\n                    pinned.forEach(side => {\n                        addClasses.push(`${ pinnedClass }-${ side }`);\n                    });\n                }\n                _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, this.options.outOfBoundsClass);\n                if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n                    eAttachment.left = tAttachment.left = false;\n                }\n                if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n                    eAttachment.top = tAttachment.top = false;\n                }\n                if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== this.attachment.top || eAttachment.left !== this.attachment.left) {\n                    this.updateAttachClasses(eAttachment, tAttachment);\n                    this.trigger('update', {\n                        attachment: eAttachment,\n                        targetAttachment: tAttachment\n                    });\n                }\n            });\n            deferred.defer(() => {\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, addClasses, allClasses);\n                }\n                _classes.updateClasses(this.element, addClasses, allClasses);\n            });\n            return {\n                top,\n                left\n            };\n        }\n    };\n});\ndefine('skylark-tether/shift',['./utils/type-check'], function (typecheck) {\n    'use strict';\n    return {\n        position({top, left}) {\n            if (!this.options.shift) {\n                return;\n            }\n            let {shift} = this.options;\n            if (typecheck.isFunction(shift)) {\n                shift = shift.call(this, {\n                    top,\n                    left\n                });\n            }\n            let shiftTop, shiftLeft;\n            if (typecheck.isString(shift)) {\n                shift = shift.split(' ');\n                shift[1] = shift[1] || shift[0];\n                [shiftTop, shiftLeft] = shift;\n                shiftTop = parseFloat(shiftTop, 10);\n                shiftLeft = parseFloat(shiftLeft, 10);\n            } else {\n                [shiftTop, shiftLeft] = [\n                    shift.top,\n                    shift.left\n                ];\n            }\n            top += shiftTop;\n            left += shiftLeft;\n            return {\n                top,\n                left\n            };\n        }\n    };\n});\ndefine('skylark-tether/evented',['./utils/type-check'], function (typecheck) {\n    'use strict';\n    class Evented {\n        on(event, handler, ctx, once = false) {\n            if (typecheck.isUndefined(this.bindings)) {\n                this.bindings = {};\n            }\n            if (typecheck.isUndefined(this.bindings[event])) {\n                this.bindings[event] = [];\n            }\n            this.bindings[event].push({\n                handler,\n                ctx,\n                once\n            });\n            return this;\n        }\n        once(event, handler, ctx) {\n            return this.on(event, handler, ctx, true);\n        }\n        off(event, handler) {\n            if (typecheck.isUndefined(this.bindings) || typecheck.isUndefined(this.bindings[event])) {\n                return this;\n            }\n            if (typecheck.isUndefined(handler)) {\n                delete this.bindings[event];\n            } else {\n                this.bindings[event].forEach((binding, index) => {\n                    if (binding.handler === handler) {\n                        this.bindings[event].splice(index, 1);\n                    }\n                });\n            }\n            return this;\n        }\n        trigger(event, ...args) {\n            if (!typecheck.isUndefined(this.bindings) && this.bindings[event]) {\n                this.bindings[event].forEach((binding, index) => {\n                    const {ctx, handler, once} = binding;\n                    const context = ctx || this;\n                    handler.apply(context, args);\n                    if (once) {\n                        this.bindings[event].splice(index, 1);\n                    }\n                });\n            }\n            return this;\n        }\n    }\n    return { Evented: Evented };\n});\ndefine('skylark-tether/utils/offset',['./type-check'], function (typecheck) {\n    'use strict';\n    const MIRROR_LR = {\n        center: 'center',\n        left: 'right',\n        right: 'left'\n    };\n    const MIRROR_TB = {\n        middle: 'middle',\n        top: 'bottom',\n        bottom: 'top'\n    };\n    const OFFSET_MAP = {\n        top: 0,\n        left: 0,\n        middle: '50%',\n        center: '50%',\n        bottom: '100%',\n        right: '100%'\n    };\n    function addOffset(...offsets) {\n        const out = {\n            top: 0,\n            left: 0\n        };\n        offsets.forEach(({top, left}) => {\n            if (typecheck.isString(top)) {\n                top = parseFloat(top);\n            }\n            if (typecheck.isString(left)) {\n                left = parseFloat(left);\n            }\n            out.top += top;\n            out.left += left;\n        });\n        return out;\n    }\n    function attachmentToOffset(attachment) {\n        let {left, top} = attachment;\n        if (!typecheck.isUndefined(OFFSET_MAP[attachment.left])) {\n            left = OFFSET_MAP[attachment.left];\n        }\n        if (!typecheck.isUndefined(OFFSET_MAP[attachment.top])) {\n            top = OFFSET_MAP[attachment.top];\n        }\n        return {\n            left,\n            top\n        };\n    }\n    function autoToFixedAttachment(attachment, relativeToAttachment) {\n        let {left, top} = attachment;\n        if (left === 'auto') {\n            left = MIRROR_LR[relativeToAttachment.left];\n        }\n        if (top === 'auto') {\n            top = MIRROR_TB[relativeToAttachment.top];\n        }\n        return {\n            left,\n            top\n        };\n    }\n    function offsetToPx(offset, size) {\n        if (typecheck.isString(offset.left) && offset.left.indexOf('%') !== -1) {\n            offset.left = parseFloat(offset.left) / 100 * size.width;\n        }\n        if (typecheck.isString(offset.top) && offset.top.indexOf('%') !== -1) {\n            offset.top = parseFloat(offset.top) / 100 * size.height;\n        }\n        return offset;\n    }\n    function parseTopLeft(value) {\n        const [top, left] = value.split(' ');\n        return {\n            top,\n            left\n        };\n    }\n    return {\n        addOffset: addOffset,\n        attachmentToOffset: attachmentToOffset,\n        autoToFixedAttachment: autoToFixedAttachment,\n        offsetToPx: offsetToPx,\n        parseTopLeft: parseTopLeft\n    };\n});\ndefine('skylark-tether/utils/parents',['./type-check'], function (typecheck) {\n    'use strict';\n    function getScrollParents(el) {\n        const computedStyle = getComputedStyle(el) || {};\n        const {position} = computedStyle;\n        let parents = [];\n        if (position === 'fixed') {\n            return [el];\n        }\n        let parent = el;\n        while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n            let style;\n            try {\n                style = getComputedStyle(parent);\n            } catch (err) {\n            }\n            if (typecheck.isUndefined(style) || style === null) {\n                parents.push(parent);\n                return parents;\n            }\n            const {overflow, overflowX, overflowY} = style;\n            if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n                if (position !== 'absolute' || [\n                        'relative',\n                        'absolute',\n                        'fixed'\n                    ].indexOf(style.position) >= 0) {\n                    parents.push(parent);\n                }\n            }\n        }\n        parents.push(el.ownerDocument.body);\n        if (el.ownerDocument !== document) {\n            parents.push(el.ownerDocument.defaultView);\n        }\n        return parents;\n    }\n    function getOffsetParent(el) {\n        return el.offsetParent || document.documentElement;\n    }\n    return {\n        getScrollParents: getScrollParents,\n        getOffsetParent: getOffsetParent\n    };\n});\ndefine('skylark-tether/Tether',[\n    \"skylark-langx/skylark\",\n    './abutment',\n    './constraint',\n    './shift',\n    './evented',\n    './utils/classes',\n    './utils/deferred',\n    './utils/general',\n    './utils/offset',\n    './utils/bounds',\n    './utils/parents',\n    './utils/type-check'\n], function (skylark,Abutment, Constraint, Shift, evented, _classes, deferred, general, _offset, bounds, parents, typecheck) {\n    'use strict';\n    const TetherBase = {\n        modules: [\n            Constraint,\n            Abutment,\n            Shift\n        ]\n    };\n    function isFullscreenElement(e) {\n        let d = e.ownerDocument;\n        let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n        return fe === e;\n    }\n    function within(a, b, diff = 1) {\n        return a + diff >= b && b >= a - diff;\n    }\n    const transformKey = (() => {\n        if (typecheck.isUndefined(document)) {\n            return '';\n        }\n        const el = document.createElement('div');\n        const transforms = [\n            'transform',\n            'WebkitTransform',\n            'OTransform',\n            'MozTransform',\n            'msTransform'\n        ];\n        for (let i = 0; i < transforms.length; ++i) {\n            const key = transforms[i];\n            if (el.style[key] !== undefined) {\n                return key;\n            }\n        }\n    })();\n    const tethers = [];\n    const position = () => {\n        tethers.forEach(tether => {\n            tether.position(false);\n        });\n        deferred.flush();\n    };\n    function now() {\n        return performance.now();\n    }\n    (() => {\n        let lastCall = null;\n        let lastDuration = null;\n        let pendingTimeout = null;\n        const tick = () => {\n            if (!typecheck.isUndefined(lastDuration) && lastDuration > 16) {\n                lastDuration = Math.min(lastDuration - 16, 250);\n                pendingTimeout = setTimeout(tick, 250);\n                return;\n            }\n            if (!typecheck.isUndefined(lastCall) && now() - lastCall < 10) {\n                return;\n            }\n            if (pendingTimeout != null) {\n                clearTimeout(pendingTimeout);\n                pendingTimeout = null;\n            }\n            lastCall = now();\n            position();\n            lastDuration = now() - lastCall;\n        };\n        if (!typecheck.isUndefined(window) && !typecheck.isUndefined(window.addEventListener)) {\n            [\n                'resize',\n                'scroll',\n                'touchmove'\n            ].forEach(event => {\n                window.addEventListener(event, tick);\n            });\n        }\n    })();\n    class TetherClass extends evented.Evented {\n        constructor(options) {\n            super();\n            this.position = this.position.bind(this);\n            tethers.push(this);\n            this.history = [];\n            this.setOptions(options, false);\n            TetherBase.modules.forEach(module => {\n                if (!typecheck.isUndefined(module.initialize)) {\n                    module.initialize.call(this);\n                }\n            });\n            this.position();\n        }\n        setOptions(options, pos = true) {\n            const defaults = {\n                offset: '0 0',\n                targetOffset: '0 0',\n                targetAttachment: 'auto auto',\n                classPrefix: 'tether',\n                bodyElement: document.body\n            };\n            this.options = general.extend(defaults, options);\n            let {element, target, targetModifier, bodyElement} = this.options;\n            this.element = element;\n            this.target = target;\n            this.targetModifier = targetModifier;\n            if (typeof bodyElement === 'string') {\n                bodyElement = document.querySelector(bodyElement);\n            }\n            this.bodyElement = bodyElement;\n            if (this.target === 'viewport') {\n                this.target = document.body;\n                this.targetModifier = 'visible';\n            } else if (this.target === 'scroll-handle') {\n                this.target = document.body;\n                this.targetModifier = 'scroll-handle';\n            }\n            [\n                'element',\n                'target'\n            ].forEach(key => {\n                if (typecheck.isUndefined(this[key])) {\n                    throw new Error('Tether Error: Both element and target must be defined');\n                }\n                if (!typecheck.isUndefined(this[key].jquery)) {\n                    this[key] = this[key][0];\n                } else if (typecheck.isString(this[key])) {\n                    this[key] = document.querySelector(this[key]);\n                }\n            });\n            this._addClasses();\n            if (!this.options.attachment) {\n                throw new Error('Tether Error: You must provide an attachment');\n            }\n            this.targetAttachment = _offset.parseTopLeft(this.options.targetAttachment);\n            this.attachment = _offset.parseTopLeft(this.options.attachment);\n            this.offset = _offset.parseTopLeft(this.options.offset);\n            this.targetOffset = _offset.parseTopLeft(this.options.targetOffset);\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.disable();\n            }\n            if (this.targetModifier === 'scroll-handle') {\n                this.scrollParents = [this.target];\n            } else {\n                this.scrollParents = parents.getScrollParents(this.target);\n            }\n            if (!(this.options.enabled === false)) {\n                this.enable(pos);\n            }\n        }\n        getTargetBounds() {\n            if (!typecheck.isUndefined(this.targetModifier)) {\n                if (this.targetModifier === 'visible') {\n                    return bounds.getVisibleBounds(this.bodyElement, this.target);\n                } else if (this.targetModifier === 'scroll-handle') {\n                    return bounds.getScrollHandleBounds(this.bodyElement, this.target);\n                }\n            } else {\n                return bounds.getBounds(this.bodyElement, this.target);\n            }\n        }\n        clearCache() {\n            this._cache = {};\n        }\n        cache(k, getter) {\n            if (typecheck.isUndefined(this._cache)) {\n                this._cache = {};\n            }\n            if (typecheck.isUndefined(this._cache[k])) {\n                this._cache[k] = getter.call(this);\n            }\n            return this._cache[k];\n        }\n        enable(pos = true) {\n            const {classes, classPrefix} = this.options;\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            }\n            _classes.addClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = true;\n            this.scrollParents.forEach(parent => {\n                if (parent !== this.target.ownerDocument) {\n                    parent.addEventListener('scroll', this.position);\n                }\n            });\n            if (pos) {\n                this.position();\n            }\n        }\n        disable() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            _classes.removeClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = false;\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.scrollParents.forEach(parent => {\n                    parent.removeEventListener('scroll', this.position);\n                });\n            }\n        }\n        destroy() {\n            this.disable();\n            this._removeClasses();\n            tethers.forEach((tether, i) => {\n                if (tether === this) {\n                    tethers.splice(i, 1);\n                }\n            });\n            if (tethers.length === 0) {\n                bounds.removeUtilElements(this.bodyElement);\n            }\n        }\n        updateAttachClasses(elementAttach, targetAttach) {\n            elementAttach = elementAttach || this.attachment;\n            targetAttach = targetAttach || this.targetAttachment;\n            const sides = [\n                'left',\n                'top',\n                'bottom',\n                'right',\n                'middle',\n                'center'\n            ];\n            const {classes, classPrefix} = this.options;\n            if (!typecheck.isUndefined(this._addAttachClasses) && this._addAttachClasses.length) {\n                this._addAttachClasses.splice(0, this._addAttachClasses.length);\n            }\n            if (typecheck.isUndefined(this._addAttachClasses)) {\n                this._addAttachClasses = [];\n            }\n            this.add = this._addAttachClasses;\n            if (elementAttach.top) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.top }`);\n            }\n            if (elementAttach.left) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.left }`);\n            }\n            if (targetAttach.top) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.top }`);\n            }\n            if (targetAttach.left) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.left }`);\n            }\n            this.all = [];\n            sides.forEach(side => {\n                this.all.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ side }`);\n                this.all.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ side }`);\n            });\n            deferred.defer(() => {\n                if (typecheck.isUndefined(this._addAttachClasses)) {\n                    return;\n                }\n                _classes.updateClasses(this.element, this._addAttachClasses, this.all);\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, this._addAttachClasses, this.all);\n                }\n                delete this._addAttachClasses;\n            });\n        }\n        position(flushChanges = true) {\n            if (!this.enabled) {\n                return;\n            }\n            this.clearCache();\n            const targetAttachment = _offset.autoToFixedAttachment(this.targetAttachment, this.attachment);\n            this.updateAttachClasses(this.attachment, targetAttachment);\n            const elementPos = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.bodyElement, this.element);\n            });\n            let {width, height} = elementPos;\n            if (width === 0 && height === 0 && !typecheck.isUndefined(this.lastSize)) {\n                ({width, height} = this.lastSize);\n            } else {\n                this.lastSize = {\n                    width,\n                    height\n                };\n            }\n            const targetPos = this.cache('target-bounds', () => {\n                return this.getTargetBounds();\n            });\n            const targetSize = targetPos;\n            let offset = _offset.offsetToPx(_offset.attachmentToOffset(this.attachment), {\n                width,\n                height\n            });\n            let targetOffset = _offset.offsetToPx(_offset.attachmentToOffset(targetAttachment), targetSize);\n            const manualOffset = _offset.offsetToPx(this.offset, {\n                width,\n                height\n            });\n            const manualTargetOffset = _offset.offsetToPx(this.targetOffset, targetSize);\n            offset = _offset.addOffset(offset, manualOffset);\n            targetOffset = _offset.addOffset(targetOffset, manualTargetOffset);\n            let left = targetPos.left + targetOffset.left - offset.left;\n            let top = targetPos.top + targetOffset.top - offset.top;\n\n\n            let scrollbarSize;\n\n            for (let i = 0; i < TetherBase.modules.length; ++i) {\n                const module = TetherBase.modules[i];\n                const ret = module.position.call(this, {\n                    left,\n                    top,\n                    targetAttachment,\n                    targetPos,\n                    elementPos,\n                    offset,\n                    targetOffset,\n                    manualOffset,\n                    manualTargetOffset,\n                    scrollbarSize,\n                    attachment: this.attachment\n                });\n                if (ret === false) {\n                    return false;\n                } else if (typecheck.isUndefined(ret) || !typecheck.isObject(ret)) {\n                    continue;\n                } else {\n                    ({top, left} = ret);\n                }\n            }\n            const next = {\n                page: {\n                    top,\n                    left\n                },\n                viewport: {\n                    top: top - pageYOffset,\n                    bottom: pageYOffset - top - height + innerHeight,\n                    left: left - pageXOffset,\n                    right: pageXOffset - left - width + innerWidth\n                }\n            };\n            let doc = this.target.ownerDocument;\n            let win = doc.defaultView;\n            if (win.innerHeight > doc.documentElement.clientHeight) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.bottom -= scrollbarSize.height;\n            }\n            if (win.innerWidth > doc.documentElement.clientWidth) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.right -= scrollbarSize.width;\n            }\n            if ([\n                    '',\n                    'static'\n                ].indexOf(doc.body.style.position) === -1 || [\n                    '',\n                    'static'\n                ].indexOf(doc.body.parentElement.style.position) === -1) {\n                next.page.bottom = doc.body.scrollHeight - top - height;\n                next.page.right = doc.body.scrollWidth - left - width;\n            }\n            if (!typecheck.isUndefined(this.options.optimizations) && this.options.optimizations.moveElement !== false && typecheck.isUndefined(this.targetModifier)) {\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                const offsetPosition = this.cache('target-offsetparent-bounds', () => bounds.getBounds(this.bodyElement, offsetParent));\n                const offsetParentStyle = getComputedStyle(offsetParent);\n                const offsetParentSize = offsetPosition;\n                const offsetBorder = {};\n                [\n                    'Top',\n                    'Left',\n                    'Bottom',\n                    'Right'\n                ].forEach(side => {\n                    offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${ side }Width`]);\n                });\n                offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n                offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n                if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\n                    if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\n                        const {scrollLeft, scrollTop} = offsetParent;\n                        next.offset = {\n                            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n                            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n                        };\n                    }\n                }\n            }\n            this.move(next);\n            this.history.unshift(next);\n            if (this.history.length > 3) {\n                this.history.pop();\n            }\n            if (flushChanges) {\n                deferred.flush();\n            }\n            return true;\n        }\n        move(pos) {\n            if (typecheck.isUndefined(this.element.parentNode)) {\n                return;\n            }\n            const same = {};\n            for (let type in pos) {\n                same[type] = {};\n                for (let key in pos[type]) {\n                    let found = false;\n                    for (let i = 0; i < this.history.length; ++i) {\n                        const point = this.history[i];\n                        if (!typecheck.isUndefined(point[type]) && !within(point[type][key], pos[type][key])) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        same[type][key] = true;\n                    }\n                }\n            }\n            let css = {\n                top: '',\n                left: '',\n                right: '',\n                bottom: ''\n            };\n            const transcribe = (_same, _pos) => {\n                const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n                const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n                if (gpu !== false) {\n                    let yPos, xPos;\n                    if (_same.top) {\n                        css.top = 0;\n                        yPos = _pos.top;\n                    } else {\n                        css.bottom = 0;\n                        yPos = -_pos.bottom;\n                    }\n                    if (_same.left) {\n                        css.left = 0;\n                        xPos = _pos.left;\n                    } else {\n                        css.right = 0;\n                        xPos = -_pos.right;\n                    }\n                    if (typecheck.isNumber(window.devicePixelRatio) && devicePixelRatio % 1 === 0) {\n                        xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n                        yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n                    }\n                    css[transformKey] = `translateX(${ xPos }px) translateY(${ yPos }px)`;\n                    if (transformKey !== 'msTransform') {\n                        css[transformKey] += ' translateZ(0)';\n                    }\n                } else {\n                    if (_same.top) {\n                        css.top = `${ _pos.top }px`;\n                    } else {\n                        css.bottom = `${ _pos.bottom }px`;\n                    }\n                    if (_same.left) {\n                        css.left = `${ _pos.left }px`;\n                    } else {\n                        css.right = `${ _pos.right }px`;\n                    }\n                }\n            };\n            const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n            let allowPositionFixed = true;\n            if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n                allowPositionFixed = false;\n            }\n            let moved = false;\n            if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n                css.position = 'absolute';\n                transcribe(same.page, pos.page);\n            } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n                css.position = 'fixed';\n                transcribe(same.viewport, pos.viewport);\n            } else if (!typecheck.isUndefined(same.offset) && same.offset.top && same.offset.left) {\n                css.position = 'absolute';\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                if (parents.getOffsetParent(this.element) !== offsetParent) {\n                    deferred.defer(() => {\n                        this.element.parentNode.removeChild(this.element);\n                        offsetParent.appendChild(this.element);\n                    });\n                }\n                transcribe(same.offset, pos.offset);\n                moved = true;\n            } else {\n                css.position = 'absolute';\n                transcribe({\n                    top: true,\n                    left: true\n                }, pos.page);\n            }\n            if (!moved) {\n                if (this.options.bodyElement) {\n                    if (this.element.parentNode !== this.options.bodyElement) {\n                        this.options.bodyElement.appendChild(this.element);\n                    }\n                } else {\n                    let offsetParentIsBody = true;\n                    let currentNode = this.element.parentNode;\n                    while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n                        if (getComputedStyle(currentNode).position !== 'static') {\n                            offsetParentIsBody = false;\n                            break;\n                        }\n                        currentNode = currentNode.parentNode;\n                    }\n                    if (!offsetParentIsBody) {\n                        this.element.parentNode.removeChild(this.element);\n                        this.element.ownerDocument.body.appendChild(this.element);\n                    }\n                }\n            }\n            const writeCSS = {};\n            let write = false;\n            for (let key in css) {\n                let val = css[key];\n                let elVal = this.element.style[key];\n                if (elVal !== val) {\n                    write = true;\n                    writeCSS[key] = val;\n                }\n            }\n            if (write) {\n                deferred.defer(() => {\n                    general.extend(this.element.style, writeCSS);\n                    this.trigger('repositioned');\n                });\n            }\n        }\n        _addClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.addClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n        }\n        _removeClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.removeClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n            this.all.forEach(className => {\n                this.element.classList.remove(className);\n                this.target.classList.remove(className);\n            });\n        }\n    }\n    TetherClass.modules = [];\n    TetherBase.position = position;\n    let Tether = general.extend(TetherClass, TetherBase);\n    Tether.modules.push({\n        initialize() {\n            const {classes, classPrefix} = this.options;\n            this.markers = {};\n            [\n                'target',\n                'element'\n            ].forEach(type => {\n                const el = document.createElement('div');\n                el.className = _classes.getClass(`${ type }-marker`, classes, classPrefix);\n                const dot = document.createElement('div');\n                dot.className = _classes.getClass('marker-dot', classes, classPrefix);\n                el.appendChild(dot);\n                this[type].appendChild(el);\n                this.markers[type] = {\n                    dot,\n                    el\n                };\n            });\n        },\n        position({manualOffset, manualTargetOffset}) {\n            const offsets = {\n                element: manualOffset,\n                target: manualTargetOffset\n            };\n            for (let type in offsets) {\n                const offset = offsets[type];\n                for (let side in offset) {\n                    let val = offset[side];\n                    if (!typecheck.isString(val) || val.indexOf('%') === -1 && val.indexOf('px') === -1) {\n                        val += 'px';\n                    }\n                    if (this.markers[type].dot.style[side] !== val) {\n                        this.markers[type].dot.style[side] = val;\n                    }\n                }\n            }\n            return true;\n        }\n    });\n    return skylark.attach(\"intg.Tether\", Tether);\n});\ndefine('skylark-tether/main',[\"./Tether\"],function(Tether){\r\n\treturn Tether;\r\n});\ndefine('skylark-tether', ['skylark-tether/main'], function (main) { return main; });\n\n"]}