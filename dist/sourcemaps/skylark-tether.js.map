{"version":3,"sources":["skylark-tether.js"],"names":["define","isFunction","value","isNumber","isObject","isString","isUndefined","undefined","typecheck","addClass","el","name","split","forEach","cls","trim","classList","add","removeClass","remove","getClass","key","classes","classPrefix","updateClasses","all","indexOf","contains","deferred","defer","fn","push","flush","pop","_scrollBarSize","extend","out","args","Array","prototype","apply","arguments","slice","obj","hasOwnProperty","call","uniqueId","id","getScrollBarSize","inner","document","createElement","style","width","height","outer","position","top","left","pointerEvents","visibility","overflow","appendChild","body","widthContained","offsetWidth","widthScroll","clientWidth","removeChild","general","zeroPosCache","zeroElement","getBounds","doc","documentElement","ownerDocument","docEl","box","_getActualBoundingClientRect","origin","node","setAttribute","getAttribute","_getOrigin","scrollWidth","right","scrollHeight","bottom","clientTop","clientLeft","clientHeight","boundingRect","getBoundingClientRect","rect","k","frameElement","defaultView","frameRect","err","getScrollHandleBounds","target","bounds","targetScrollTop","scrollTop","targetIsBody","pageXOffset","pageYOffset","innerHeight","innerWidth","getComputedStyle","scrollBottom","overflowX","parseFloat","borderTopWidth","borderBottomWidth","borderLeftWidth","fitAdj","Math","pow","max","scrollPercentage","getVisibleBounds","min","removeUtilElements","_classes","[object Object]","this","cache","element","targetPos","getTargetBounds","abutted","side","targetPosSide","options","length","addTargetClasses","BOUNDS_FORMAT","getBoundingRect","tether","to","scrollParents","nodeType","size","pos","win","i","toUpperCase","substr","targetAttachment","constraints","bodyElement","lastSize","targetSize","targetHeight","targetWidth","allClasses","constraint","outOfBoundsClass","pinnedClass","_getAllClasses","addClasses","tAttachment","eAttachment","attachment","changeAttachX","changeAttachY","pin","_flipYTogether","_flipXTogether","map","p","pinned","oob","_calculateOOBAndPinnedLeft","_calculateOOBAndPinnedTop","oobClass","_addOutOfBoundsClass","updateAttachClasses","trigger","shift","shiftTop","shiftLeft","Evented","event","handler","ctx","once","bindings","on","binding","index","splice","context","MIRROR_LR","center","MIRROR_TB","middle","OFFSET_MAP","addOffset","offsets","attachmentToOffset","autoToFixedAttachment","relativeToAttachment","offsetToPx","offset","parseTopLeft","getScrollParents","computedStyle","parents","parent","parentNode","overflowY","test","getOffsetParent","offsetParent","skylark","Abutment","Constraint","Shift","evented","_offset","TetherBase","modules","isFullscreenElement","e","d","fe","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","within","a","b","diff","transformKey","transforms","tethers","now","performance","lastCall","lastDuration","pendingTimeout","tick","setTimeout","clearTimeout","window","addEventListener","TetherClass","super","bind","history","setOptions","module","initialize","defaults","targetOffset","targetModifier","querySelector","Error","jquery","_addClasses","disable","enabled","enable","_cache","getter","removeEventListener","_removeClasses","elementAttach","targetAttach","_addAttachClasses","flushChanges","clearCache","elementPos","manualOffset","manualTargetOffset","scrollbarSize","ret","next","page","viewport","parentElement","optimizations","moveElement","offsetPosition","offsetParentStyle","offsetParentSize","offsetBorder","toLowerCase","scrollLeft","move","unshift","same","type","found","point","css","transcribe","_same","_pos","hasOptimizations","gpu","yPos","xPos","devicePixelRatio","round","allowPositionFixed","moved","offsetParentIsBody","currentNode","tagName","writeCSS","write","val","elVal","className","Tether","markers","dot","attach","main"],"mappings":"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","file":"../skylark-tether.js","sourcesContent":["define('skylark-tether/utils/type-check',[],function () {\n    'use strict';\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    function isNumber(value) {\n        return typeof value === 'number';\n    }\n    function isObject(value) {\n        return typeof value === 'object';\n    }\n    function isString(value) {\n        return typeof value === 'string';\n    }\n    function isUndefined(value) {\n        return value === undefined;\n    }\n    return {\n        isFunction: isFunction,\n        isNumber: isNumber,\n        isObject: isObject,\n        isString: isString,\n        isUndefined: isUndefined\n    };\n});\ndefine('skylark-tether/utils/classes',['./type-check'], function (typecheck) {\n    'use strict';\n    function addClass(el, name) {\n        name.split(' ').forEach(cls => {\n            if (cls.trim()) {\n                el.classList.add(cls);\n            }\n        });\n    }\n    function getClass(key = '', classes, classPrefix) {\n        if (!typecheck.isUndefined(classes) && !typecheck.isUndefined(classes[key])) {\n            if (classes[key] === false) {\n                return '';\n            }\n            return classes[key];\n        } else if (classPrefix) {\n            return `${ classPrefix }-${ key }`;\n        } else {\n            return key;\n        }\n    }\n    function removeClass(el, name) {\n        name.split(' ').forEach(cls => {\n            if (cls.trim()) {\n                el.classList.remove(cls);\n            }\n        });\n    }\n    function updateClasses(el, add, all) {\n        all.forEach(cls => {\n            if (add.indexOf(cls) === -1 && el.classList.contains(cls)) {\n                removeClass(el, cls);\n            }\n        });\n        add.forEach(cls => {\n            if (!el.classList.contains(cls)) {\n                addClass(el, cls);\n            }\n        });\n    }\n    return {\n        addClass: addClass,\n        getClass: getClass,\n        removeClass: removeClass,\n        updateClasses: updateClasses\n    };\n});\ndefine('skylark-tether/utils/deferred',[],function () {\n    'use strict';\n    const deferred = [];\n    function defer(fn) {\n        deferred.push(fn);\n    }\n    function flush() {\n        let fn;\n        while (fn = deferred.pop()) {\n            fn();\n        }\n    }\n    return {\n        defer: defer,\n        flush: flush\n    };\n});\ndefine('skylark-tether/utils/general',[],function () {\n    'use strict';\n    let _scrollBarSize = null;\n    function extend(out = {}) {\n        const args = [];\n        Array.prototype.push.apply(args, arguments);\n        args.slice(1).forEach(obj => {\n            if (obj) {\n                for (let key in obj) {\n                    if ({}.hasOwnProperty.call(obj, key)) {\n                        out[key] = obj[key];\n                    }\n                }\n            }\n        });\n        return out;\n    }\n    function getScrollBarSize() {\n        if (_scrollBarSize) {\n            return _scrollBarSize;\n        }\n        const inner = document.createElement('div');\n        inner.style.width = '100%';\n        inner.style.height = '200px';\n        const outer = document.createElement('div');\n        extend(outer.style, {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            pointerEvents: 'none',\n            visibility: 'hidden',\n            width: '200px',\n            height: '150px',\n            overflow: 'hidden'\n        });\n        outer.appendChild(inner);\n        document.body.appendChild(outer);\n        const widthContained = inner.offsetWidth;\n        outer.style.overflow = 'scroll';\n        let widthScroll = inner.offsetWidth;\n        if (widthContained === widthScroll) {\n            widthScroll = outer.clientWidth;\n        }\n        document.body.removeChild(outer);\n        const width = widthContained - widthScroll;\n        _scrollBarSize = {\n            width,\n            height: width\n        };\n        return _scrollBarSize;\n    }\n    const uniqueId = (() => {\n        let id = 0;\n        return () => ++id;\n    })();\n    return {\n        extend: extend,\n        getScrollBarSize: getScrollBarSize,\n        uniqueId: uniqueId\n    };\n});\ndefine('skylark-tether/utils/bounds',[\n    './deferred',\n    './general',\n    './type-check'\n], function (deferred, general, typecheck) {\n    'use strict';\n    const zeroPosCache = {};\n    let zeroElement = null;\n    function getBounds(body, el) {\n        let doc;\n        if (el === document) {\n            doc = document;\n            el = document.documentElement;\n        } else {\n            doc = el.ownerDocument;\n        }\n        const docEl = doc.documentElement;\n        const box = _getActualBoundingClientRect(el);\n        const origin = _getOrigin(body);\n        box.top -= origin.top;\n        box.left -= origin.left;\n        if (typecheck.isUndefined(box.width)) {\n            box.width = document.body.scrollWidth - box.left - box.right;\n        }\n        if (typecheck.isUndefined(box.height)) {\n            box.height = document.body.scrollHeight - box.top - box.bottom;\n        }\n        box.top = box.top - docEl.clientTop;\n        box.left = box.left - docEl.clientLeft;\n        box.right = doc.body.clientWidth - box.width - box.left;\n        box.bottom = doc.body.clientHeight - box.height - box.top;\n        return box;\n    }\n    function getScrollHandleBounds(body, target) {\n        let bounds;\n        const targetScrollTop = target.scrollTop;\n        const targetIsBody = target === document.body;\n        if (targetIsBody) {\n            target = document.documentElement;\n            bounds = {\n                left: pageXOffset,\n                top: pageYOffset,\n                height: innerHeight,\n                width: innerWidth\n            };\n        } else {\n            bounds = getBounds(body, target);\n        }\n        const style = getComputedStyle(target);\n        const hasBottomScroll = target.scrollWidth > target.clientWidth || [\n            style.overflow,\n            style.overflowX\n        ].indexOf('scroll') >= 0 || !targetIsBody;\n        let scrollBottom = 0;\n        if (hasBottomScroll) {\n            scrollBottom = 15;\n        }\n        const height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n        const out = {\n            width: 15,\n            height: height * 0.975 * (height / target.scrollHeight),\n            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n        };\n        let fitAdj = 0;\n        if (height < 408 && targetIsBody) {\n            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n        }\n        if (!targetIsBody) {\n            out.height = Math.max(out.height, 24);\n        }\n        const scrollPercentage = targetScrollTop / (target.scrollHeight - height);\n        out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n        if (targetIsBody) {\n            out.height = Math.max(out.height, 24);\n        }\n        return out;\n    }\n    function getVisibleBounds(body, target) {\n        if (target === document.body) {\n            return {\n                top: pageYOffset,\n                left: pageXOffset,\n                height: innerHeight,\n                width: innerWidth\n            };\n        } else {\n            const bounds = getBounds(body, target);\n            const out = {\n                height: bounds.height,\n                width: bounds.width,\n                top: bounds.top,\n                left: bounds.left\n            };\n            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\n            out.height = Math.min(innerHeight, out.height);\n            out.height -= 2;\n            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\n            out.width = Math.min(innerWidth, out.width);\n            out.width -= 2;\n            if (out.top < pageYOffset) {\n                out.top = pageYOffset;\n            }\n            if (out.left < pageXOffset) {\n                out.left = pageXOffset;\n            }\n            return out;\n        }\n    }\n    function removeUtilElements(body) {\n        if (zeroElement) {\n            body.removeChild(zeroElement);\n        }\n        zeroElement = null;\n    }\n    function _getActualBoundingClientRect(node) {\n        let boundingRect = node.getBoundingClientRect();\n        let rect = {};\n        for (let k in boundingRect) {\n            rect[k] = boundingRect[k];\n        }\n        try {\n            if (node.ownerDocument !== document) {\n                let {frameElement} = node.ownerDocument.defaultView;\n                if (frameElement) {\n                    let frameRect = _getActualBoundingClientRect(frameElement);\n                    rect.top += frameRect.top;\n                    rect.bottom += frameRect.top;\n                    rect.left += frameRect.left;\n                    rect.right += frameRect.left;\n                }\n            }\n        } catch (err) {\n        }\n        return rect;\n    }\n    function _getOrigin(body) {\n        let node = zeroElement;\n        if (!node || !body.contains(node)) {\n            node = document.createElement('div');\n            node.setAttribute('data-tether-id', general.uniqueId());\n            general.extend(node.style, {\n                top: 0,\n                left: 0,\n                position: 'absolute'\n            });\n            body.appendChild(node);\n            zeroElement = node;\n        }\n        const id = node.getAttribute('data-tether-id');\n        if (typecheck.isUndefined(zeroPosCache[id])) {\n            zeroPosCache[id] = _getActualBoundingClientRect(node);\n            deferred.defer(() => {\n                delete zeroPosCache[id];\n            });\n        }\n        return zeroPosCache[id];\n    }\n    return {\n        getBounds: getBounds,\n        getScrollHandleBounds: getScrollHandleBounds,\n        getVisibleBounds: getVisibleBounds,\n        removeUtilElements: removeUtilElements\n    };\n});\ndefine('skylark-tether/abutment',[\n    './utils/classes',\n    './utils/deferred',\n    './utils/bounds'\n], function (_classes, deferred, bounds) {\n    'use strict';\n    return {\n        position({top, left}) {\n            const {height, width} = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.element);\n            });\n            const targetPos = this.getTargetBounds();\n            const bottom = top + height;\n            const right = left + width;\n            const abutted = [];\n            if (top <= targetPos.bottom && bottom >= targetPos.top) {\n                [\n                    'left',\n                    'right'\n                ].forEach(side => {\n                    const targetPosSide = targetPos[side];\n                    if (targetPosSide === left || targetPosSide === right) {\n                        abutted.push(side);\n                    }\n                });\n            }\n            if (left <= targetPos.right && right >= targetPos.left) {\n                [\n                    'top',\n                    'bottom'\n                ].forEach(side => {\n                    const targetPosSide = targetPos[side];\n                    if (targetPosSide === top || targetPosSide === bottom) {\n                        abutted.push(side);\n                    }\n                });\n            }\n            const sides = [\n                'left',\n                'top',\n                'right',\n                'bottom'\n            ];\n            const {classes, classPrefix} = this.options;\n            this.all.push(_classes.getClass('abutted', classes, classPrefix));\n            sides.forEach(side => {\n                this.all.push(`${ _classes.getClass('abutted', classes, classPrefix) }-${ side }`);\n            });\n            if (abutted.length) {\n                this.add.push(_classes.getClass('abutted', classes, classPrefix));\n            }\n            abutted.forEach(side => {\n                this.add.push(`${ _classes.getClass('abutted', classes, classPrefix) }-${ side }`);\n            });\n            deferred.defer(() => {\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, this.add, this.all);\n                }\n                _classes.updateClasses(this.element, this.add, this.all);\n            });\n            return true;\n        }\n    };\n});\ndefine('skylark-tether/constraint',[\n    './utils/classes',\n    './utils/deferred',\n    './utils/general',\n    './utils/bounds',\n    './utils/type-check'\n], function (_classes, deferred, general, bounds, typecheck) {\n    'use strict';\n    const BOUNDS_FORMAT = [\n        'left',\n        'top',\n        'right',\n        'bottom'\n    ];\n    function getBoundingRect(body, tether, to) {\n        if (!to) {\n            return null;\n        }\n        if (to === 'scrollParent') {\n            to = tether.scrollParents[0];\n        } else if (to === 'window') {\n            to = [\n                pageXOffset,\n                pageYOffset,\n                innerWidth + pageXOffset,\n                innerHeight + pageYOffset\n            ];\n        }\n        if (to === document) {\n            to = to.documentElement;\n        }\n        if (!typecheck.isUndefined(to.nodeType)) {\n            const node = to;\n            const size = bounds.getBounds(body, to);\n            const pos = size;\n            const style = getComputedStyle(to);\n            to = [\n                pos.left,\n                pos.top,\n                size.width + pos.left,\n                size.height + pos.top\n            ];\n            if (node.ownerDocument !== document) {\n                let win = node.ownerDocument.defaultView;\n                to[0] += win.pageXOffset;\n                to[1] += win.pageYOffset;\n                to[2] += win.pageXOffset;\n                to[3] += win.pageYOffset;\n            }\n            BOUNDS_FORMAT.forEach((side, i) => {\n                side = side[0].toUpperCase() + side.substr(1);\n                if (side === 'Top' || side === 'Left') {\n                    to[i] += parseFloat(style[`border${ side }Width`]);\n                } else {\n                    to[i] -= parseFloat(style[`border${ side }Width`]);\n                }\n            });\n        }\n        return to;\n    }\n    function _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, outOfBoundsClass) {\n        if (oob.length) {\n            let oobClass;\n            if (!typecheck.isUndefined(outOfBoundsClass)) {\n                oobClass = outOfBoundsClass;\n            } else {\n                oobClass = _classes.getClass('out-of-bounds', classes, classPrefix);\n            }\n            addClasses.push(oobClass);\n            oob.forEach(side => {\n                addClasses.push(`${ oobClass }-${ side }`);\n            });\n        }\n    }\n    function _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob) {\n        if (left < bounds[0]) {\n            if (pin.indexOf('left') >= 0) {\n                left = bounds[0];\n                pinned.push('left');\n            } else {\n                oob.push('left');\n            }\n        }\n        if (left + width > bounds[2]) {\n            if (pin.indexOf('right') >= 0) {\n                left = bounds[2] - width;\n                pinned.push('right');\n            } else {\n                oob.push('right');\n            }\n        }\n        return left;\n    }\n    function _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob) {\n        if (top < bounds[1]) {\n            if (pin.indexOf('top') >= 0) {\n                top = bounds[1];\n                pinned.push('top');\n            } else {\n                oob.push('top');\n            }\n        }\n        if (top + height > bounds[3]) {\n            if (pin.indexOf('bottom') >= 0) {\n                top = bounds[3] - height;\n                pinned.push('bottom');\n            } else {\n                oob.push('bottom');\n            }\n        }\n        return top;\n    }\n    function _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left) {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n            if (eAttachment.left === 'right') {\n                left += targetWidth;\n                tAttachment.left = 'right';\n                left += width;\n                eAttachment.left = 'left';\n            } else if (eAttachment.left === 'left') {\n                left += targetWidth;\n                tAttachment.left = 'right';\n                left -= width;\n                eAttachment.left = 'right';\n            }\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n            if (eAttachment.left === 'left') {\n                left -= targetWidth;\n                tAttachment.left = 'left';\n                left -= width;\n                eAttachment.left = 'right';\n            } else if (eAttachment.left === 'right') {\n                left -= targetWidth;\n                tAttachment.left = 'left';\n                left += width;\n                eAttachment.left = 'left';\n            }\n        } else if (tAttachment.left === 'center') {\n            if (left + width > bounds[2] && eAttachment.left === 'left') {\n                left -= width;\n                eAttachment.left = 'right';\n            } else if (left < bounds[0] && eAttachment.left === 'right') {\n                left += width;\n                eAttachment.left = 'left';\n            }\n        }\n        return left;\n    }\n    function _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top) {\n        if (tAttachment.top === 'top') {\n            if (eAttachment.top === 'bottom' && top < bounds[1]) {\n                top += targetHeight;\n                tAttachment.top = 'bottom';\n                top += height;\n                eAttachment.top = 'top';\n            } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n                top -= height - targetHeight;\n                tAttachment.top = 'bottom';\n                eAttachment.top = 'bottom';\n            }\n        }\n        if (tAttachment.top === 'bottom') {\n            if (eAttachment.top === 'top' && top + height > bounds[3]) {\n                top -= targetHeight;\n                tAttachment.top = 'top';\n                top -= height;\n                eAttachment.top = 'bottom';\n            } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n                top += height - targetHeight;\n                tAttachment.top = 'top';\n                eAttachment.top = 'top';\n            }\n        }\n        if (tAttachment.top === 'middle') {\n            if (top + height > bounds[3] && eAttachment.top === 'top') {\n                top -= height;\n                eAttachment.top = 'bottom';\n            } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n                top += height;\n                eAttachment.top = 'top';\n            }\n        }\n        return top;\n    }\n    function _getAllClasses(classes, classPrefix, constraints) {\n        const allClasses = [\n            _classes.getClass('pinned', classes, classPrefix),\n            _classes.getClass('out-of-bounds', classes, classPrefix)\n        ];\n        constraints.forEach(constraint => {\n            const {outOfBoundsClass, pinnedClass} = constraint;\n            if (outOfBoundsClass) {\n                allClasses.push(outOfBoundsClass);\n            }\n            if (pinnedClass) {\n                allClasses.push(pinnedClass);\n            }\n        });\n        allClasses.forEach(cls => {\n            [\n                'left',\n                'top',\n                'right',\n                'bottom'\n            ].forEach(side => {\n                allClasses.push(`${ cls }-${ side }`);\n            });\n        });\n        return allClasses;\n    }\n    return {\n        position({top, left, targetAttachment}) {\n            if (!this.options.constraints) {\n                return true;\n            }\n            let {height, width} = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.bodyElement, this.element);\n            });\n            if (width === 0 && height === 0 && !typecheck.isUndefined(this.lastSize)) {\n                ({width, height} = this.lastSize);\n            }\n            const targetSize = this.cache('target-bounds', () => {\n                return this.getTargetBounds();\n            });\n            const {\n                height: targetHeight,\n                width: targetWidth\n            } = targetSize;\n            const {classes, classPrefix} = this.options;\n            const allClasses = _getAllClasses(classes, classPrefix, this.options.constraints);\n            const addClasses = [];\n            const tAttachment = general.extend({}, targetAttachment);\n            const eAttachment = general.extend({}, this.attachment);\n            this.options.constraints.forEach(constraint => {\n                let {to, attachment, pin} = constraint;\n                if (typecheck.isUndefined(attachment)) {\n                    attachment = '';\n                }\n                let changeAttachX, changeAttachY;\n                if (attachment.indexOf(' ') >= 0) {\n                    [changeAttachY, changeAttachX] = attachment.split(' ');\n                } else {\n                    changeAttachX = changeAttachY = attachment;\n                }\n                const bounds = getBoundingRect(this.bodyElement, this, to);\n                if (changeAttachY === 'target' || changeAttachY === 'both') {\n                    if (top < bounds[1] && tAttachment.top === 'top') {\n                        top += targetHeight;\n                        tAttachment.top = 'bottom';\n                    }\n                    if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n                        top -= targetHeight;\n                        tAttachment.top = 'top';\n                    }\n                }\n                if (changeAttachY === 'together') {\n                    top = _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top);\n                }\n                if (changeAttachX === 'target' || changeAttachX === 'both') {\n                    if (left < bounds[0] && tAttachment.left === 'left') {\n                        left += targetWidth;\n                        tAttachment.left = 'right';\n                    }\n                    if (left + width > bounds[2] && tAttachment.left === 'right') {\n                        left -= targetWidth;\n                        tAttachment.left = 'left';\n                    }\n                }\n                if (changeAttachX === 'together') {\n                    left = _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left);\n                }\n                if (changeAttachY === 'element' || changeAttachY === 'both') {\n                    if (top < bounds[1] && eAttachment.top === 'bottom') {\n                        top += height;\n                        eAttachment.top = 'top';\n                    }\n                    if (top + height > bounds[3] && eAttachment.top === 'top') {\n                        top -= height;\n                        eAttachment.top = 'bottom';\n                    }\n                }\n                if (changeAttachX === 'element' || changeAttachX === 'both') {\n                    if (left < bounds[0]) {\n                        if (eAttachment.left === 'right') {\n                            left += width;\n                            eAttachment.left = 'left';\n                        } else if (eAttachment.left === 'center') {\n                            left += width / 2;\n                            eAttachment.left = 'left';\n                        }\n                    }\n                    if (left + width > bounds[2]) {\n                        if (eAttachment.left === 'left') {\n                            left -= width;\n                            eAttachment.left = 'right';\n                        } else if (eAttachment.left === 'center') {\n                            left -= width / 2;\n                            eAttachment.left = 'right';\n                        }\n                    }\n                }\n                if (typecheck.isString(pin)) {\n                    pin = pin.split(',').map(p => p.trim());\n                } else if (pin === true) {\n                    pin = [\n                        'top',\n                        'left',\n                        'right',\n                        'bottom'\n                    ];\n                }\n                pin = pin || [];\n                const pinned = [];\n                const oob = [];\n                left = _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob);\n                top = _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob);\n                if (pinned.length) {\n                    let pinnedClass;\n                    if (!typecheck.isUndefined(this.options.pinnedClass)) {\n                        pinnedClass = this.options.pinnedClass;\n                    } else {\n                        pinnedClass = _classes.getClass('pinned', classes, classPrefix);\n                    }\n                    addClasses.push(pinnedClass);\n                    pinned.forEach(side => {\n                        addClasses.push(`${ pinnedClass }-${ side }`);\n                    });\n                }\n                _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, this.options.outOfBoundsClass);\n                if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n                    eAttachment.left = tAttachment.left = false;\n                }\n                if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n                    eAttachment.top = tAttachment.top = false;\n                }\n                if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== this.attachment.top || eAttachment.left !== this.attachment.left) {\n                    this.updateAttachClasses(eAttachment, tAttachment);\n                    this.trigger('update', {\n                        attachment: eAttachment,\n                        targetAttachment: tAttachment\n                    });\n                }\n            });\n            deferred.defer(() => {\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, addClasses, allClasses);\n                }\n                _classes.updateClasses(this.element, addClasses, allClasses);\n            });\n            return {\n                top,\n                left\n            };\n        }\n    };\n});\ndefine('skylark-tether/shift',['./utils/type-check'], function (typecheck) {\n    'use strict';\n    return {\n        position({top, left}) {\n            if (!this.options.shift) {\n                return;\n            }\n            let {shift} = this.options;\n            if (typecheck.isFunction(shift)) {\n                shift = shift.call(this, {\n                    top,\n                    left\n                });\n            }\n            let shiftTop, shiftLeft;\n            if (typecheck.isString(shift)) {\n                shift = shift.split(' ');\n                shift[1] = shift[1] || shift[0];\n                [shiftTop, shiftLeft] = shift;\n                shiftTop = parseFloat(shiftTop, 10);\n                shiftLeft = parseFloat(shiftLeft, 10);\n            } else {\n                [shiftTop, shiftLeft] = [\n                    shift.top,\n                    shift.left\n                ];\n            }\n            top += shiftTop;\n            left += shiftLeft;\n            return {\n                top,\n                left\n            };\n        }\n    };\n});\ndefine('skylark-tether/evented',['./utils/type-check'], function (typecheck) {\n    'use strict';\n    class Evented {\n        on(event, handler, ctx, once = false) {\n            if (typecheck.isUndefined(this.bindings)) {\n                this.bindings = {};\n            }\n            if (typecheck.isUndefined(this.bindings[event])) {\n                this.bindings[event] = [];\n            }\n            this.bindings[event].push({\n                handler,\n                ctx,\n                once\n            });\n            return this;\n        }\n        once(event, handler, ctx) {\n            return this.on(event, handler, ctx, true);\n        }\n        off(event, handler) {\n            if (typecheck.isUndefined(this.bindings) || typecheck.isUndefined(this.bindings[event])) {\n                return this;\n            }\n            if (typecheck.isUndefined(handler)) {\n                delete this.bindings[event];\n            } else {\n                this.bindings[event].forEach((binding, index) => {\n                    if (binding.handler === handler) {\n                        this.bindings[event].splice(index, 1);\n                    }\n                });\n            }\n            return this;\n        }\n        trigger(event, ...args) {\n            if (!typecheck.isUndefined(this.bindings) && this.bindings[event]) {\n                this.bindings[event].forEach((binding, index) => {\n                    const {ctx, handler, once} = binding;\n                    const context = ctx || this;\n                    handler.apply(context, args);\n                    if (once) {\n                        this.bindings[event].splice(index, 1);\n                    }\n                });\n            }\n            return this;\n        }\n    }\n    return { Evented: Evented };\n});\ndefine('skylark-tether/utils/offset',['./type-check'], function (typecheck) {\n    'use strict';\n    const MIRROR_LR = {\n        center: 'center',\n        left: 'right',\n        right: 'left'\n    };\n    const MIRROR_TB = {\n        middle: 'middle',\n        top: 'bottom',\n        bottom: 'top'\n    };\n    const OFFSET_MAP = {\n        top: 0,\n        left: 0,\n        middle: '50%',\n        center: '50%',\n        bottom: '100%',\n        right: '100%'\n    };\n    function addOffset(...offsets) {\n        const out = {\n            top: 0,\n            left: 0\n        };\n        offsets.forEach(({top, left}) => {\n            if (typecheck.isString(top)) {\n                top = parseFloat(top);\n            }\n            if (typecheck.isString(left)) {\n                left = parseFloat(left);\n            }\n            out.top += top;\n            out.left += left;\n        });\n        return out;\n    }\n    function attachmentToOffset(attachment) {\n        let {left, top} = attachment;\n        if (!typecheck.isUndefined(OFFSET_MAP[attachment.left])) {\n            left = OFFSET_MAP[attachment.left];\n        }\n        if (!typecheck.isUndefined(OFFSET_MAP[attachment.top])) {\n            top = OFFSET_MAP[attachment.top];\n        }\n        return {\n            left,\n            top\n        };\n    }\n    function autoToFixedAttachment(attachment, relativeToAttachment) {\n        let {left, top} = attachment;\n        if (left === 'auto') {\n            left = MIRROR_LR[relativeToAttachment.left];\n        }\n        if (top === 'auto') {\n            top = MIRROR_TB[relativeToAttachment.top];\n        }\n        return {\n            left,\n            top\n        };\n    }\n    function offsetToPx(offset, size) {\n        if (typecheck.isString(offset.left) && offset.left.indexOf('%') !== -1) {\n            offset.left = parseFloat(offset.left) / 100 * size.width;\n        }\n        if (typecheck.isString(offset.top) && offset.top.indexOf('%') !== -1) {\n            offset.top = parseFloat(offset.top) / 100 * size.height;\n        }\n        return offset;\n    }\n    function parseTopLeft(value) {\n        const [top, left] = value.split(' ');\n        return {\n            top,\n            left\n        };\n    }\n    return {\n        addOffset: addOffset,\n        attachmentToOffset: attachmentToOffset,\n        autoToFixedAttachment: autoToFixedAttachment,\n        offsetToPx: offsetToPx,\n        parseTopLeft: parseTopLeft\n    };\n});\ndefine('skylark-tether/utils/parents',['./type-check'], function (typecheck) {\n    'use strict';\n    function getScrollParents(el) {\n        const computedStyle = getComputedStyle(el) || {};\n        const {position} = computedStyle;\n        let parents = [];\n        if (position === 'fixed') {\n            return [el];\n        }\n        let parent = el;\n        while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n            let style;\n            try {\n                style = getComputedStyle(parent);\n            } catch (err) {\n            }\n            if (typecheck.isUndefined(style) || style === null) {\n                parents.push(parent);\n                return parents;\n            }\n            const {overflow, overflowX, overflowY} = style;\n            if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n                if (position !== 'absolute' || [\n                        'relative',\n                        'absolute',\n                        'fixed'\n                    ].indexOf(style.position) >= 0) {\n                    parents.push(parent);\n                }\n            }\n        }\n        parents.push(el.ownerDocument.body);\n        if (el.ownerDocument !== document) {\n            parents.push(el.ownerDocument.defaultView);\n        }\n        return parents;\n    }\n    function getOffsetParent(el) {\n        return el.offsetParent || document.documentElement;\n    }\n    return {\n        getScrollParents: getScrollParents,\n        getOffsetParent: getOffsetParent\n    };\n});\ndefine('skylark-tether/Tether',[\n    \"skylark-langx/skylark\",\n    './abutment',\n    './constraint',\n    './shift',\n    './evented',\n    './utils/classes',\n    './utils/deferred',\n    './utils/general',\n    './utils/offset',\n    './utils/bounds',\n    './utils/parents',\n    './utils/type-check'\n], function (skylark,Abutment, Constraint, Shift, evented, _classes, deferred, general, _offset, bounds, parents, typecheck) {\n    'use strict';\n    const TetherBase = {\n        modules: [\n            Constraint,\n            Abutment,\n            Shift\n        ]\n    };\n    function isFullscreenElement(e) {\n        let d = e.ownerDocument;\n        let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n        return fe === e;\n    }\n    function within(a, b, diff = 1) {\n        return a + diff >= b && b >= a - diff;\n    }\n    const transformKey = (() => {\n        if (typecheck.isUndefined(document)) {\n            return '';\n        }\n        const el = document.createElement('div');\n        const transforms = [\n            'transform',\n            'WebkitTransform',\n            'OTransform',\n            'MozTransform',\n            'msTransform'\n        ];\n        for (let i = 0; i < transforms.length; ++i) {\n            const key = transforms[i];\n            if (el.style[key] !== undefined) {\n                return key;\n            }\n        }\n    })();\n    const tethers = [];\n    const position = () => {\n        tethers.forEach(tether => {\n            tether.position(false);\n        });\n        deferred.flush();\n    };\n    function now() {\n        return performance.now();\n    }\n    (() => {\n        let lastCall = null;\n        let lastDuration = null;\n        let pendingTimeout = null;\n        const tick = () => {\n            if (!typecheck.isUndefined(lastDuration) && lastDuration > 16) {\n                lastDuration = Math.min(lastDuration - 16, 250);\n                pendingTimeout = setTimeout(tick, 250);\n                return;\n            }\n            if (!typecheck.isUndefined(lastCall) && now() - lastCall < 10) {\n                return;\n            }\n            if (pendingTimeout != null) {\n                clearTimeout(pendingTimeout);\n                pendingTimeout = null;\n            }\n            lastCall = now();\n            position();\n            lastDuration = now() - lastCall;\n        };\n        if (!typecheck.isUndefined(window) && !typecheck.isUndefined(window.addEventListener)) {\n            [\n                'resize',\n                'scroll',\n                'touchmove'\n            ].forEach(event => {\n                window.addEventListener(event, tick);\n            });\n        }\n    })();\n    class TetherClass extends evented.Evented {\n        constructor(options) {\n            super();\n            this.position = this.position.bind(this);\n            tethers.push(this);\n            this.history = [];\n            this.setOptions(options, false);\n            TetherBase.modules.forEach(module => {\n                if (!typecheck.isUndefined(module.initialize)) {\n                    module.initialize.call(this);\n                }\n            });\n            this.position();\n        }\n        setOptions(options, pos = true) {\n            const defaults = {\n                offset: '0 0',\n                targetOffset: '0 0',\n                targetAttachment: 'auto auto',\n                classPrefix: 'tether',\n                bodyElement: document.body\n            };\n            this.options = general.extend(defaults, options);\n            let {element, target, targetModifier, bodyElement} = this.options;\n            this.element = element;\n            this.target = target;\n            this.targetModifier = targetModifier;\n            if (typeof bodyElement === 'string') {\n                bodyElement = document.querySelector(bodyElement);\n            }\n            this.bodyElement = bodyElement;\n            if (this.target === 'viewport') {\n                this.target = document.body;\n                this.targetModifier = 'visible';\n            } else if (this.target === 'scroll-handle') {\n                this.target = document.body;\n                this.targetModifier = 'scroll-handle';\n            }\n            [\n                'element',\n                'target'\n            ].forEach(key => {\n                if (typecheck.isUndefined(this[key])) {\n                    throw new Error('Tether Error: Both element and target must be defined');\n                }\n                if (!typecheck.isUndefined(this[key].jquery)) {\n                    this[key] = this[key][0];\n                } else if (typecheck.isString(this[key])) {\n                    this[key] = document.querySelector(this[key]);\n                }\n            });\n            this._addClasses();\n            if (!this.options.attachment) {\n                throw new Error('Tether Error: You must provide an attachment');\n            }\n            this.targetAttachment = _offset.parseTopLeft(this.options.targetAttachment);\n            this.attachment = _offset.parseTopLeft(this.options.attachment);\n            this.offset = _offset.parseTopLeft(this.options.offset);\n            this.targetOffset = _offset.parseTopLeft(this.options.targetOffset);\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.disable();\n            }\n            if (this.targetModifier === 'scroll-handle') {\n                this.scrollParents = [this.target];\n            } else {\n                this.scrollParents = parents.getScrollParents(this.target);\n            }\n            if (!(this.options.enabled === false)) {\n                this.enable(pos);\n            }\n        }\n        getTargetBounds() {\n            if (!typecheck.isUndefined(this.targetModifier)) {\n                if (this.targetModifier === 'visible') {\n                    return bounds.getVisibleBounds(this.bodyElement, this.target);\n                } else if (this.targetModifier === 'scroll-handle') {\n                    return bounds.getScrollHandleBounds(this.bodyElement, this.target);\n                }\n            } else {\n                return bounds.getBounds(this.bodyElement, this.target);\n            }\n        }\n        clearCache() {\n            this._cache = {};\n        }\n        cache(k, getter) {\n            if (typecheck.isUndefined(this._cache)) {\n                this._cache = {};\n            }\n            if (typecheck.isUndefined(this._cache[k])) {\n                this._cache[k] = getter.call(this);\n            }\n            return this._cache[k];\n        }\n        enable(pos = true) {\n            const {classes, classPrefix} = this.options;\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            }\n            _classes.addClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = true;\n            this.scrollParents.forEach(parent => {\n                if (parent !== this.target.ownerDocument) {\n                    parent.addEventListener('scroll', this.position);\n                }\n            });\n            if (pos) {\n                this.position();\n            }\n        }\n        disable() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            _classes.removeClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = false;\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.scrollParents.forEach(parent => {\n                    parent.removeEventListener('scroll', this.position);\n                });\n            }\n        }\n        destroy() {\n            this.disable();\n            this._removeClasses();\n            tethers.forEach((tether, i) => {\n                if (tether === this) {\n                    tethers.splice(i, 1);\n                }\n            });\n            if (tethers.length === 0) {\n                bounds.removeUtilElements(this.bodyElement);\n            }\n        }\n        updateAttachClasses(elementAttach, targetAttach) {\n            elementAttach = elementAttach || this.attachment;\n            targetAttach = targetAttach || this.targetAttachment;\n            const sides = [\n                'left',\n                'top',\n                'bottom',\n                'right',\n                'middle',\n                'center'\n            ];\n            const {classes, classPrefix} = this.options;\n            if (!typecheck.isUndefined(this._addAttachClasses) && this._addAttachClasses.length) {\n                this._addAttachClasses.splice(0, this._addAttachClasses.length);\n            }\n            if (typecheck.isUndefined(this._addAttachClasses)) {\n                this._addAttachClasses = [];\n            }\n            this.add = this._addAttachClasses;\n            if (elementAttach.top) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.top }`);\n            }\n            if (elementAttach.left) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.left }`);\n            }\n            if (targetAttach.top) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.top }`);\n            }\n            if (targetAttach.left) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.left }`);\n            }\n            this.all = [];\n            sides.forEach(side => {\n                this.all.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ side }`);\n                this.all.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ side }`);\n            });\n            deferred.defer(() => {\n                if (typecheck.isUndefined(this._addAttachClasses)) {\n                    return;\n                }\n                _classes.updateClasses(this.element, this._addAttachClasses, this.all);\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, this._addAttachClasses, this.all);\n                }\n                delete this._addAttachClasses;\n            });\n        }\n        position(flushChanges = true) {\n            if (!this.enabled) {\n                return;\n            }\n            this.clearCache();\n            const targetAttachment = _offset.autoToFixedAttachment(this.targetAttachment, this.attachment);\n            this.updateAttachClasses(this.attachment, targetAttachment);\n            const elementPos = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.bodyElement, this.element);\n            });\n            let {width, height} = elementPos;\n            if (width === 0 && height === 0 && !typecheck.isUndefined(this.lastSize)) {\n                ({width, height} = this.lastSize);\n            } else {\n                this.lastSize = {\n                    width,\n                    height\n                };\n            }\n            const targetPos = this.cache('target-bounds', () => {\n                return this.getTargetBounds();\n            });\n            const targetSize = targetPos;\n            let offset = _offset.offsetToPx(_offset.attachmentToOffset(this.attachment), {\n                width,\n                height\n            });\n            let targetOffset = _offset.offsetToPx(_offset.attachmentToOffset(targetAttachment), targetSize);\n            const manualOffset = _offset.offsetToPx(this.offset, {\n                width,\n                height\n            });\n            const manualTargetOffset = _offset.offsetToPx(this.targetOffset, targetSize);\n            offset = _offset.addOffset(offset, manualOffset);\n            targetOffset = _offset.addOffset(targetOffset, manualTargetOffset);\n            let left = targetPos.left + targetOffset.left - offset.left;\n            let top = targetPos.top + targetOffset.top - offset.top;\n\n\n            let scrollbarSize;\n\n            for (let i = 0; i < TetherBase.modules.length; ++i) {\n                const module = TetherBase.modules[i];\n                const ret = module.position.call(this, {\n                    left,\n                    top,\n                    targetAttachment,\n                    targetPos,\n                    elementPos,\n                    offset,\n                    targetOffset,\n                    manualOffset,\n                    manualTargetOffset,\n                    scrollbarSize,\n                    attachment: this.attachment\n                });\n                if (ret === false) {\n                    return false;\n                } else if (typecheck.isUndefined(ret) || !typecheck.isObject(ret)) {\n                    continue;\n                } else {\n                    ({top, left} = ret);\n                }\n            }\n            const next = {\n                page: {\n                    top,\n                    left\n                },\n                viewport: {\n                    top: top - pageYOffset,\n                    bottom: pageYOffset - top - height + innerHeight,\n                    left: left - pageXOffset,\n                    right: pageXOffset - left - width + innerWidth\n                }\n            };\n            let doc = this.target.ownerDocument;\n            let win = doc.defaultView;\n            if (win.innerHeight > doc.documentElement.clientHeight) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.bottom -= scrollbarSize.height;\n            }\n            if (win.innerWidth > doc.documentElement.clientWidth) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.right -= scrollbarSize.width;\n            }\n            if ([\n                    '',\n                    'static'\n                ].indexOf(doc.body.style.position) === -1 || [\n                    '',\n                    'static'\n                ].indexOf(doc.body.parentElement.style.position) === -1) {\n                next.page.bottom = doc.body.scrollHeight - top - height;\n                next.page.right = doc.body.scrollWidth - left - width;\n            }\n            if (!typecheck.isUndefined(this.options.optimizations) && this.options.optimizations.moveElement !== false && typecheck.isUndefined(this.targetModifier)) {\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                const offsetPosition = this.cache('target-offsetparent-bounds', () => bounds.getBounds(this.bodyElement, offsetParent));\n                const offsetParentStyle = getComputedStyle(offsetParent);\n                const offsetParentSize = offsetPosition;\n                const offsetBorder = {};\n                [\n                    'Top',\n                    'Left',\n                    'Bottom',\n                    'Right'\n                ].forEach(side => {\n                    offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${ side }Width`]);\n                });\n                offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n                offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n                if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\n                    if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\n                        const {scrollLeft, scrollTop} = offsetParent;\n                        next.offset = {\n                            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n                            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n                        };\n                    }\n                }\n            }\n            this.move(next);\n            this.history.unshift(next);\n            if (this.history.length > 3) {\n                this.history.pop();\n            }\n            if (flushChanges) {\n                deferred.flush();\n            }\n            return true;\n        }\n        move(pos) {\n            if (typecheck.isUndefined(this.element.parentNode)) {\n                return;\n            }\n            const same = {};\n            for (let type in pos) {\n                same[type] = {};\n                for (let key in pos[type]) {\n                    let found = false;\n                    for (let i = 0; i < this.history.length; ++i) {\n                        const point = this.history[i];\n                        if (!typecheck.isUndefined(point[type]) && !within(point[type][key], pos[type][key])) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        same[type][key] = true;\n                    }\n                }\n            }\n            let css = {\n                top: '',\n                left: '',\n                right: '',\n                bottom: ''\n            };\n            const transcribe = (_same, _pos) => {\n                const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n                const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n                if (gpu !== false) {\n                    let yPos, xPos;\n                    if (_same.top) {\n                        css.top = 0;\n                        yPos = _pos.top;\n                    } else {\n                        css.bottom = 0;\n                        yPos = -_pos.bottom;\n                    }\n                    if (_same.left) {\n                        css.left = 0;\n                        xPos = _pos.left;\n                    } else {\n                        css.right = 0;\n                        xPos = -_pos.right;\n                    }\n                    if (typecheck.isNumber(window.devicePixelRatio) && devicePixelRatio % 1 === 0) {\n                        xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n                        yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n                    }\n                    css[transformKey] = `translateX(${ xPos }px) translateY(${ yPos }px)`;\n                    if (transformKey !== 'msTransform') {\n                        css[transformKey] += ' translateZ(0)';\n                    }\n                } else {\n                    if (_same.top) {\n                        css.top = `${ _pos.top }px`;\n                    } else {\n                        css.bottom = `${ _pos.bottom }px`;\n                    }\n                    if (_same.left) {\n                        css.left = `${ _pos.left }px`;\n                    } else {\n                        css.right = `${ _pos.right }px`;\n                    }\n                }\n            };\n            const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n            let allowPositionFixed = true;\n            if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n                allowPositionFixed = false;\n            }\n            let moved = false;\n            if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n                css.position = 'absolute';\n                transcribe(same.page, pos.page);\n            } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n                css.position = 'fixed';\n                transcribe(same.viewport, pos.viewport);\n            } else if (!typecheck.isUndefined(same.offset) && same.offset.top && same.offset.left) {\n                css.position = 'absolute';\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                if (parents.getOffsetParent(this.element) !== offsetParent) {\n                    deferred.defer(() => {\n                        this.element.parentNode.removeChild(this.element);\n                        offsetParent.appendChild(this.element);\n                    });\n                }\n                transcribe(same.offset, pos.offset);\n                moved = true;\n            } else {\n                css.position = 'absolute';\n                transcribe({\n                    top: true,\n                    left: true\n                }, pos.page);\n            }\n            if (!moved) {\n                if (this.options.bodyElement) {\n                    if (this.element.parentNode !== this.options.bodyElement) {\n                        this.options.bodyElement.appendChild(this.element);\n                    }\n                } else {\n                    let offsetParentIsBody = true;\n                    let currentNode = this.element.parentNode;\n                    while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n                        if (getComputedStyle(currentNode).position !== 'static') {\n                            offsetParentIsBody = false;\n                            break;\n                        }\n                        currentNode = currentNode.parentNode;\n                    }\n                    if (!offsetParentIsBody) {\n                        this.element.parentNode.removeChild(this.element);\n                        this.element.ownerDocument.body.appendChild(this.element);\n                    }\n                }\n            }\n            const writeCSS = {};\n            let write = false;\n            for (let key in css) {\n                let val = css[key];\n                let elVal = this.element.style[key];\n                if (elVal !== val) {\n                    write = true;\n                    writeCSS[key] = val;\n                }\n            }\n            if (write) {\n                deferred.defer(() => {\n                    general.extend(this.element.style, writeCSS);\n                    this.trigger('repositioned');\n                });\n            }\n        }\n        _addClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.addClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n        }\n        _removeClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.removeClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n            this.all.forEach(className => {\n                this.element.classList.remove(className);\n                this.target.classList.remove(className);\n            });\n        }\n    }\n    TetherClass.modules = [];\n    TetherBase.position = position;\n    let Tether = general.extend(TetherClass, TetherBase);\n    Tether.modules.push({\n        initialize() {\n            const {classes, classPrefix} = this.options;\n            this.markers = {};\n            [\n                'target',\n                'element'\n            ].forEach(type => {\n                const el = document.createElement('div');\n                el.className = _classes.getClass(`${ type }-marker`, classes, classPrefix);\n                const dot = document.createElement('div');\n                dot.className = _classes.getClass('marker-dot', classes, classPrefix);\n                el.appendChild(dot);\n                this[type].appendChild(el);\n                this.markers[type] = {\n                    dot,\n                    el\n                };\n            });\n        },\n        position({manualOffset, manualTargetOffset}) {\n            const offsets = {\n                element: manualOffset,\n                target: manualTargetOffset\n            };\n            for (let type in offsets) {\n                const offset = offsets[type];\n                for (let side in offset) {\n                    let val = offset[side];\n                    if (!typecheck.isString(val) || val.indexOf('%') === -1 && val.indexOf('px') === -1) {\n                        val += 'px';\n                    }\n                    if (this.markers[type].dot.style[side] !== val) {\n                        this.markers[type].dot.style[side] = val;\n                    }\n                }\n            }\n            return true;\n        }\n    });\n    return skylark.attach(\"intg.Tether\", Tether);\n});\ndefine('skylark-tether/main',[\"./Tether\"],function(Tether){\r\n\treturn Tether;\r\n});\ndefine('skylark-tether', ['skylark-tether/main'], function (main) { return main; });\n\n"]}