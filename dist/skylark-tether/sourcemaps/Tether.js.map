{"version":3,"sources":["Tether.js"],"names":["define","skylark","Abutment","Constraint","Shift","evented","_classes","deferred","general","_offset","bounds","parents","typecheck","TetherBase","modules","isFullscreenElement","e","d","ownerDocument","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","within","a","b","diff","transformKey","isUndefined","document","el","createElement","transforms","i","length","key","undefined","style","tethers","position","forEach","tether","flush","now","performance","lastCall","lastDuration","pendingTimeout","tick","Math","min","setTimeout","clearTimeout","window","addEventListener","event","TetherClass","Evented","[object Object]","options","super","this","bind","push","history","setOptions","module","initialize","call","pos","defaults","offset","targetOffset","targetAttachment","classPrefix","bodyElement","body","extend","element","target","targetModifier","querySelector","Error","jquery","isString","_addClasses","attachment","parseTopLeft","scrollParents","disable","getScrollParents","enabled","enable","getBounds","getVisibleBounds","getScrollHandleBounds","_cache","k","getter","classes","addTargetClasses","addClass","getClass","parent","removeClass","removeEventListener","_removeClasses","splice","removeUtilElements","elementAttach","targetAttach","_addAttachClasses","add","top","left","all","side","defer","updateClasses","flushChanges","clearCache","autoToFixedAttachment","updateAttachClasses","elementPos","cache","width","height","lastSize","targetPos","getTargetBounds","targetSize","offsetToPx","attachmentToOffset","manualOffset","manualTargetOffset","addOffset","scrollbarSize","ret","isObject","next","page","viewport","pageYOffset","bottom","innerHeight","pageXOffset","right","innerWidth","doc","win","defaultView","documentElement","clientHeight","getScrollBarSize","clientWidth","indexOf","parentElement","scrollHeight","scrollWidth","optimizations","moveElement","offsetParent","getOffsetParent","offsetPosition","offsetParentStyle","getComputedStyle","offsetParentSize","offsetBorder","toLowerCase","parseFloat","scrollLeft","scrollTop","move","unshift","pop","parentNode","same","type","found","point","css","transcribe","_same","_pos","gpu","yPos","xPos","isNumber","devicePixelRatio","round","allowPositionFixed","moved","removeChild","appendChild","offsetParentIsBody","currentNode","nodeType","tagName","writeCSS","write","val","trigger","className","classList","remove","Tether","markers","dot","offsets","attach"],"mappings":"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","file":"../Tether.js","sourcesContent":["define([\n    \"skylark-langx/skylark\",\n    './abutment',\n    './constraint',\n    './shift',\n    './evented',\n    './utils/classes',\n    './utils/deferred',\n    './utils/general',\n    './utils/offset',\n    './utils/bounds',\n    './utils/parents',\n    './utils/type-check'\n], function (skylark,Abutment, Constraint, Shift, evented, _classes, deferred, general, _offset, bounds, parents, typecheck) {\n    'use strict';\n    const TetherBase = {\n        modules: [\n            Constraint,\n            Abutment,\n            Shift\n        ]\n    };\n    function isFullscreenElement(e) {\n        let d = e.ownerDocument;\n        let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n        return fe === e;\n    }\n    function within(a, b, diff = 1) {\n        return a + diff >= b && b >= a - diff;\n    }\n    const transformKey = (() => {\n        if (typecheck.isUndefined(document)) {\n            return '';\n        }\n        const el = document.createElement('div');\n        const transforms = [\n            'transform',\n            'WebkitTransform',\n            'OTransform',\n            'MozTransform',\n            'msTransform'\n        ];\n        for (let i = 0; i < transforms.length; ++i) {\n            const key = transforms[i];\n            if (el.style[key] !== undefined) {\n                return key;\n            }\n        }\n    })();\n    const tethers = [];\n    const position = () => {\n        tethers.forEach(tether => {\n            tether.position(false);\n        });\n        deferred.flush();\n    };\n    function now() {\n        return performance.now();\n    }\n    (() => {\n        let lastCall = null;\n        let lastDuration = null;\n        let pendingTimeout = null;\n        const tick = () => {\n            if (!typecheck.isUndefined(lastDuration) && lastDuration > 16) {\n                lastDuration = Math.min(lastDuration - 16, 250);\n                pendingTimeout = setTimeout(tick, 250);\n                return;\n            }\n            if (!typecheck.isUndefined(lastCall) && now() - lastCall < 10) {\n                return;\n            }\n            if (pendingTimeout != null) {\n                clearTimeout(pendingTimeout);\n                pendingTimeout = null;\n            }\n            lastCall = now();\n            position();\n            lastDuration = now() - lastCall;\n        };\n        if (!typecheck.isUndefined(window) && !typecheck.isUndefined(window.addEventListener)) {\n            [\n                'resize',\n                'scroll',\n                'touchmove'\n            ].forEach(event => {\n                window.addEventListener(event, tick);\n            });\n        }\n    })();\n    class TetherClass extends evented.Evented {\n        constructor(options) {\n            super();\n            this.position = this.position.bind(this);\n            tethers.push(this);\n            this.history = [];\n            this.setOptions(options, false);\n            TetherBase.modules.forEach(module => {\n                if (!typecheck.isUndefined(module.initialize)) {\n                    module.initialize.call(this);\n                }\n            });\n            this.position();\n        }\n        setOptions(options, pos = true) {\n            const defaults = {\n                offset: '0 0',\n                targetOffset: '0 0',\n                targetAttachment: 'auto auto',\n                classPrefix: 'tether',\n                bodyElement: document.body\n            };\n            this.options = general.extend(defaults, options);\n            let {element, target, targetModifier, bodyElement} = this.options;\n            this.element = element;\n            this.target = target;\n            this.targetModifier = targetModifier;\n            if (typeof bodyElement === 'string') {\n                bodyElement = document.querySelector(bodyElement);\n            }\n            this.bodyElement = bodyElement;\n            if (this.target === 'viewport') {\n                this.target = document.body;\n                this.targetModifier = 'visible';\n            } else if (this.target === 'scroll-handle') {\n                this.target = document.body;\n                this.targetModifier = 'scroll-handle';\n            }\n            [\n                'element',\n                'target'\n            ].forEach(key => {\n                if (typecheck.isUndefined(this[key])) {\n                    throw new Error('Tether Error: Both element and target must be defined');\n                }\n                if (!typecheck.isUndefined(this[key].jquery)) {\n                    this[key] = this[key][0];\n                } else if (typecheck.isString(this[key])) {\n                    this[key] = document.querySelector(this[key]);\n                }\n            });\n            this._addClasses();\n            if (!this.options.attachment) {\n                throw new Error('Tether Error: You must provide an attachment');\n            }\n            this.targetAttachment = _offset.parseTopLeft(this.options.targetAttachment);\n            this.attachment = _offset.parseTopLeft(this.options.attachment);\n            this.offset = _offset.parseTopLeft(this.options.offset);\n            this.targetOffset = _offset.parseTopLeft(this.options.targetOffset);\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.disable();\n            }\n            if (this.targetModifier === 'scroll-handle') {\n                this.scrollParents = [this.target];\n            } else {\n                this.scrollParents = parents.getScrollParents(this.target);\n            }\n            if (!(this.options.enabled === false)) {\n                this.enable(pos);\n            }\n        }\n        getTargetBounds() {\n            if (!typecheck.isUndefined(this.targetModifier)) {\n                if (this.targetModifier === 'visible') {\n                    return bounds.getVisibleBounds(this.bodyElement, this.target);\n                } else if (this.targetModifier === 'scroll-handle') {\n                    return bounds.getScrollHandleBounds(this.bodyElement, this.target);\n                }\n            } else {\n                return bounds.getBounds(this.bodyElement, this.target);\n            }\n        }\n        clearCache() {\n            this._cache = {};\n        }\n        cache(k, getter) {\n            if (typecheck.isUndefined(this._cache)) {\n                this._cache = {};\n            }\n            if (typecheck.isUndefined(this._cache[k])) {\n                this._cache[k] = getter.call(this);\n            }\n            return this._cache[k];\n        }\n        enable(pos = true) {\n            const {classes, classPrefix} = this.options;\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            }\n            _classes.addClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = true;\n            this.scrollParents.forEach(parent => {\n                if (parent !== this.target.ownerDocument) {\n                    parent.addEventListener('scroll', this.position);\n                }\n            });\n            if (pos) {\n                this.position();\n            }\n        }\n        disable() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            _classes.removeClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = false;\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.scrollParents.forEach(parent => {\n                    parent.removeEventListener('scroll', this.position);\n                });\n            }\n        }\n        destroy() {\n            this.disable();\n            this._removeClasses();\n            tethers.forEach((tether, i) => {\n                if (tether === this) {\n                    tethers.splice(i, 1);\n                }\n            });\n            if (tethers.length === 0) {\n                bounds.removeUtilElements(this.bodyElement);\n            }\n        }\n        updateAttachClasses(elementAttach, targetAttach) {\n            elementAttach = elementAttach || this.attachment;\n            targetAttach = targetAttach || this.targetAttachment;\n            const sides = [\n                'left',\n                'top',\n                'bottom',\n                'right',\n                'middle',\n                'center'\n            ];\n            const {classes, classPrefix} = this.options;\n            if (!typecheck.isUndefined(this._addAttachClasses) && this._addAttachClasses.length) {\n                this._addAttachClasses.splice(0, this._addAttachClasses.length);\n            }\n            if (typecheck.isUndefined(this._addAttachClasses)) {\n                this._addAttachClasses = [];\n            }\n            this.add = this._addAttachClasses;\n            if (elementAttach.top) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.top }`);\n            }\n            if (elementAttach.left) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.left }`);\n            }\n            if (targetAttach.top) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.top }`);\n            }\n            if (targetAttach.left) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.left }`);\n            }\n            this.all = [];\n            sides.forEach(side => {\n                this.all.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ side }`);\n                this.all.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ side }`);\n            });\n            deferred.defer(() => {\n                if (typecheck.isUndefined(this._addAttachClasses)) {\n                    return;\n                }\n                _classes.updateClasses(this.element, this._addAttachClasses, this.all);\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, this._addAttachClasses, this.all);\n                }\n                delete this._addAttachClasses;\n            });\n        }\n        position(flushChanges = true) {\n            if (!this.enabled) {\n                return;\n            }\n            this.clearCache();\n            const targetAttachment = _offset.autoToFixedAttachment(this.targetAttachment, this.attachment);\n            this.updateAttachClasses(this.attachment, targetAttachment);\n            const elementPos = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.bodyElement, this.element);\n            });\n            let {width, height} = elementPos;\n            if (width === 0 && height === 0 && !typecheck.isUndefined(this.lastSize)) {\n                ({width, height} = this.lastSize);\n            } else {\n                this.lastSize = {\n                    width,\n                    height\n                };\n            }\n            const targetPos = this.cache('target-bounds', () => {\n                return this.getTargetBounds();\n            });\n            const targetSize = targetPos;\n            let offset = _offset.offsetToPx(_offset.attachmentToOffset(this.attachment), {\n                width,\n                height\n            });\n            let targetOffset = _offset.offsetToPx(_offset.attachmentToOffset(targetAttachment), targetSize);\n            const manualOffset = _offset.offsetToPx(this.offset, {\n                width,\n                height\n            });\n            const manualTargetOffset = _offset.offsetToPx(this.targetOffset, targetSize);\n            offset = _offset.addOffset(offset, manualOffset);\n            targetOffset = _offset.addOffset(targetOffset, manualTargetOffset);\n            let left = targetPos.left + targetOffset.left - offset.left;\n            let top = targetPos.top + targetOffset.top - offset.top;\n\n\n            let scrollbarSize;\n\n            for (let i = 0; i < TetherBase.modules.length; ++i) {\n                const module = TetherBase.modules[i];\n                const ret = module.position.call(this, {\n                    left,\n                    top,\n                    targetAttachment,\n                    targetPos,\n                    elementPos,\n                    offset,\n                    targetOffset,\n                    manualOffset,\n                    manualTargetOffset,\n                    scrollbarSize,\n                    attachment: this.attachment\n                });\n                if (ret === false) {\n                    return false;\n                } else if (typecheck.isUndefined(ret) || !typecheck.isObject(ret)) {\n                    continue;\n                } else {\n                    ({top, left} = ret);\n                }\n            }\n            const next = {\n                page: {\n                    top,\n                    left\n                },\n                viewport: {\n                    top: top - pageYOffset,\n                    bottom: pageYOffset - top - height + innerHeight,\n                    left: left - pageXOffset,\n                    right: pageXOffset - left - width + innerWidth\n                }\n            };\n            let doc = this.target.ownerDocument;\n            let win = doc.defaultView;\n            if (win.innerHeight > doc.documentElement.clientHeight) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.bottom -= scrollbarSize.height;\n            }\n            if (win.innerWidth > doc.documentElement.clientWidth) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.right -= scrollbarSize.width;\n            }\n            if ([\n                    '',\n                    'static'\n                ].indexOf(doc.body.style.position) === -1 || [\n                    '',\n                    'static'\n                ].indexOf(doc.body.parentElement.style.position) === -1) {\n                next.page.bottom = doc.body.scrollHeight - top - height;\n                next.page.right = doc.body.scrollWidth - left - width;\n            }\n            if (!typecheck.isUndefined(this.options.optimizations) && this.options.optimizations.moveElement !== false && typecheck.isUndefined(this.targetModifier)) {\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                const offsetPosition = this.cache('target-offsetparent-bounds', () => bounds.getBounds(this.bodyElement, offsetParent));\n                const offsetParentStyle = getComputedStyle(offsetParent);\n                const offsetParentSize = offsetPosition;\n                const offsetBorder = {};\n                [\n                    'Top',\n                    'Left',\n                    'Bottom',\n                    'Right'\n                ].forEach(side => {\n                    offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${ side }Width`]);\n                });\n                offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n                offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n                if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\n                    if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\n                        const {scrollLeft, scrollTop} = offsetParent;\n                        next.offset = {\n                            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n                            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n                        };\n                    }\n                }\n            }\n            this.move(next);\n            this.history.unshift(next);\n            if (this.history.length > 3) {\n                this.history.pop();\n            }\n            if (flushChanges) {\n                deferred.flush();\n            }\n            return true;\n        }\n        move(pos) {\n            if (typecheck.isUndefined(this.element.parentNode)) {\n                return;\n            }\n            const same = {};\n            for (let type in pos) {\n                same[type] = {};\n                for (let key in pos[type]) {\n                    let found = false;\n                    for (let i = 0; i < this.history.length; ++i) {\n                        const point = this.history[i];\n                        if (!typecheck.isUndefined(point[type]) && !within(point[type][key], pos[type][key])) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        same[type][key] = true;\n                    }\n                }\n            }\n            let css = {\n                top: '',\n                left: '',\n                right: '',\n                bottom: ''\n            };\n            const transcribe = (_same, _pos) => {\n                const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n                const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n                if (gpu !== false) {\n                    let yPos, xPos;\n                    if (_same.top) {\n                        css.top = 0;\n                        yPos = _pos.top;\n                    } else {\n                        css.bottom = 0;\n                        yPos = -_pos.bottom;\n                    }\n                    if (_same.left) {\n                        css.left = 0;\n                        xPos = _pos.left;\n                    } else {\n                        css.right = 0;\n                        xPos = -_pos.right;\n                    }\n                    if (typecheck.isNumber(window.devicePixelRatio) && devicePixelRatio % 1 === 0) {\n                        xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n                        yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n                    }\n                    css[transformKey] = `translateX(${ xPos }px) translateY(${ yPos }px)`;\n                    if (transformKey !== 'msTransform') {\n                        css[transformKey] += ' translateZ(0)';\n                    }\n                } else {\n                    if (_same.top) {\n                        css.top = `${ _pos.top }px`;\n                    } else {\n                        css.bottom = `${ _pos.bottom }px`;\n                    }\n                    if (_same.left) {\n                        css.left = `${ _pos.left }px`;\n                    } else {\n                        css.right = `${ _pos.right }px`;\n                    }\n                }\n            };\n            const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n            let allowPositionFixed = true;\n            if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n                allowPositionFixed = false;\n            }\n            let moved = false;\n            if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n                css.position = 'absolute';\n                transcribe(same.page, pos.page);\n            } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n                css.position = 'fixed';\n                transcribe(same.viewport, pos.viewport);\n            } else if (!typecheck.isUndefined(same.offset) && same.offset.top && same.offset.left) {\n                css.position = 'absolute';\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                if (parents.getOffsetParent(this.element) !== offsetParent) {\n                    deferred.defer(() => {\n                        this.element.parentNode.removeChild(this.element);\n                        offsetParent.appendChild(this.element);\n                    });\n                }\n                transcribe(same.offset, pos.offset);\n                moved = true;\n            } else {\n                css.position = 'absolute';\n                transcribe({\n                    top: true,\n                    left: true\n                }, pos.page);\n            }\n            if (!moved) {\n                if (this.options.bodyElement) {\n                    if (this.element.parentNode !== this.options.bodyElement) {\n                        this.options.bodyElement.appendChild(this.element);\n                    }\n                } else {\n                    let offsetParentIsBody = true;\n                    let currentNode = this.element.parentNode;\n                    while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n                        if (getComputedStyle(currentNode).position !== 'static') {\n                            offsetParentIsBody = false;\n                            break;\n                        }\n                        currentNode = currentNode.parentNode;\n                    }\n                    if (!offsetParentIsBody) {\n                        this.element.parentNode.removeChild(this.element);\n                        this.element.ownerDocument.body.appendChild(this.element);\n                    }\n                }\n            }\n            const writeCSS = {};\n            let write = false;\n            for (let key in css) {\n                let val = css[key];\n                let elVal = this.element.style[key];\n                if (elVal !== val) {\n                    write = true;\n                    writeCSS[key] = val;\n                }\n            }\n            if (write) {\n                deferred.defer(() => {\n                    general.extend(this.element.style, writeCSS);\n                    this.trigger('repositioned');\n                });\n            }\n        }\n        _addClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.addClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n        }\n        _removeClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.removeClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n            this.all.forEach(className => {\n                this.element.classList.remove(className);\n                this.target.classList.remove(className);\n            });\n        }\n    }\n    TetherClass.modules = [];\n    TetherBase.position = position;\n    let Tether = general.extend(TetherClass, TetherBase);\n    Tether.modules.push({\n        initialize() {\n            const {classes, classPrefix} = this.options;\n            this.markers = {};\n            [\n                'target',\n                'element'\n            ].forEach(type => {\n                const el = document.createElement('div');\n                el.className = _classes.getClass(`${ type }-marker`, classes, classPrefix);\n                const dot = document.createElement('div');\n                dot.className = _classes.getClass('marker-dot', classes, classPrefix);\n                el.appendChild(dot);\n                this[type].appendChild(el);\n                this.markers[type] = {\n                    dot,\n                    el\n                };\n            });\n        },\n        position({manualOffset, manualTargetOffset}) {\n            const offsets = {\n                element: manualOffset,\n                target: manualTargetOffset\n            };\n            for (let type in offsets) {\n                const offset = offsets[type];\n                for (let side in offset) {\n                    let val = offset[side];\n                    if (!typecheck.isString(val) || val.indexOf('%') === -1 && val.indexOf('px') === -1) {\n                        val += 'px';\n                    }\n                    if (this.markers[type].dot.style[side] !== val) {\n                        this.markers[type].dot.style[side] = val;\n                    }\n                }\n            }\n            return true;\n        }\n    });\n    return skylark.attach(\"intg.Tether\", Tether);\n});"]}