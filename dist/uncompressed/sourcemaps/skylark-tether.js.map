{"version":3,"sources":["skylark-tether.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-tether.js","sourcesContent":["define('skylark-tether/utils/type-check',[],function () {\n    'use strict';\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    function isNumber(value) {\n        return typeof value === 'number';\n    }\n    function isObject(value) {\n        return typeof value === 'object';\n    }\n    function isString(value) {\n        return typeof value === 'string';\n    }\n    function isUndefined(value) {\n        return value === undefined;\n    }\n    return {\n        isFunction: isFunction,\n        isNumber: isNumber,\n        isObject: isObject,\n        isString: isString,\n        isUndefined: isUndefined\n    };\n});\ndefine('skylark-tether/utils/classes',['./type-check'], function (typecheck) {\n    'use strict';\n    function addClass(el, name) {\n        name.split(' ').forEach(cls => {\n            if (cls.trim()) {\n                el.classList.add(cls);\n            }\n        });\n    }\n    function getClass(key = '', classes, classPrefix) {\n        if (!typecheck.isUndefined(classes) && !typecheck.isUndefined(classes[key])) {\n            if (classes[key] === false) {\n                return '';\n            }\n            return classes[key];\n        } else if (classPrefix) {\n            return `${ classPrefix }-${ key }`;\n        } else {\n            return key;\n        }\n    }\n    function removeClass(el, name) {\n        name.split(' ').forEach(cls => {\n            if (cls.trim()) {\n                el.classList.remove(cls);\n            }\n        });\n    }\n    function updateClasses(el, add, all) {\n        all.forEach(cls => {\n            if (add.indexOf(cls) === -1 && el.classList.contains(cls)) {\n                removeClass(el, cls);\n            }\n        });\n        add.forEach(cls => {\n            if (!el.classList.contains(cls)) {\n                addClass(el, cls);\n            }\n        });\n    }\n    return {\n        addClass: addClass,\n        getClass: getClass,\n        removeClass: removeClass,\n        updateClasses: updateClasses\n    };\n});\ndefine('skylark-tether/utils/deferred',[],function () {\n    'use strict';\n    const deferred = [];\n    function defer(fn) {\n        deferred.push(fn);\n    }\n    function flush() {\n        let fn;\n        while (fn = deferred.pop()) {\n            fn();\n        }\n    }\n    return {\n        defer: defer,\n        flush: flush\n    };\n});\ndefine('skylark-tether/utils/general',[],function () {\n    'use strict';\n    let _scrollBarSize = null;\n    function extend(out = {}) {\n        const args = [];\n        Array.prototype.push.apply(args, arguments);\n        args.slice(1).forEach(obj => {\n            if (obj) {\n                for (let key in obj) {\n                    if ({}.hasOwnProperty.call(obj, key)) {\n                        out[key] = obj[key];\n                    }\n                }\n            }\n        });\n        return out;\n    }\n    function getScrollBarSize() {\n        if (_scrollBarSize) {\n            return _scrollBarSize;\n        }\n        const inner = document.createElement('div');\n        inner.style.width = '100%';\n        inner.style.height = '200px';\n        const outer = document.createElement('div');\n        extend(outer.style, {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            pointerEvents: 'none',\n            visibility: 'hidden',\n            width: '200px',\n            height: '150px',\n            overflow: 'hidden'\n        });\n        outer.appendChild(inner);\n        document.body.appendChild(outer);\n        const widthContained = inner.offsetWidth;\n        outer.style.overflow = 'scroll';\n        let widthScroll = inner.offsetWidth;\n        if (widthContained === widthScroll) {\n            widthScroll = outer.clientWidth;\n        }\n        document.body.removeChild(outer);\n        const width = widthContained - widthScroll;\n        _scrollBarSize = {\n            width,\n            height: width\n        };\n        return _scrollBarSize;\n    }\n    const uniqueId = (() => {\n        let id = 0;\n        return () => ++id;\n    })();\n    return {\n        extend: extend,\n        getScrollBarSize: getScrollBarSize,\n        uniqueId: uniqueId\n    };\n});\ndefine('skylark-tether/utils/bounds',[\n    './deferred',\n    './general',\n    './type-check'\n], function (deferred, general, typecheck) {\n    'use strict';\n    const zeroPosCache = {};\n    let zeroElement = null;\n    function getBounds(body, el) {\n        let doc;\n        if (el === document) {\n            doc = document;\n            el = document.documentElement;\n        } else {\n            doc = el.ownerDocument;\n        }\n        const docEl = doc.documentElement;\n        const box = _getActualBoundingClientRect(el);\n        const origin = _getOrigin(body);\n        box.top -= origin.top;\n        box.left -= origin.left;\n        if (typecheck.isUndefined(box.width)) {\n            box.width = document.body.scrollWidth - box.left - box.right;\n        }\n        if (typecheck.isUndefined(box.height)) {\n            box.height = document.body.scrollHeight - box.top - box.bottom;\n        }\n        box.top = box.top - docEl.clientTop;\n        box.left = box.left - docEl.clientLeft;\n        box.right = doc.body.clientWidth - box.width - box.left;\n        box.bottom = doc.body.clientHeight - box.height - box.top;\n        return box;\n    }\n    function getScrollHandleBounds(body, target) {\n        let bounds;\n        const targetScrollTop = target.scrollTop;\n        const targetIsBody = target === document.body;\n        if (targetIsBody) {\n            target = document.documentElement;\n            bounds = {\n                left: pageXOffset,\n                top: pageYOffset,\n                height: innerHeight,\n                width: innerWidth\n            };\n        } else {\n            bounds = getBounds(body, target);\n        }\n        const style = getComputedStyle(target);\n        const hasBottomScroll = target.scrollWidth > target.clientWidth || [\n            style.overflow,\n            style.overflowX\n        ].indexOf('scroll') >= 0 || !targetIsBody;\n        let scrollBottom = 0;\n        if (hasBottomScroll) {\n            scrollBottom = 15;\n        }\n        const height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n        const out = {\n            width: 15,\n            height: height * 0.975 * (height / target.scrollHeight),\n            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n        };\n        let fitAdj = 0;\n        if (height < 408 && targetIsBody) {\n            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n        }\n        if (!targetIsBody) {\n            out.height = Math.max(out.height, 24);\n        }\n        const scrollPercentage = targetScrollTop / (target.scrollHeight - height);\n        out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n        if (targetIsBody) {\n            out.height = Math.max(out.height, 24);\n        }\n        return out;\n    }\n    function getVisibleBounds(body, target) {\n        if (target === document.body) {\n            return {\n                top: pageYOffset,\n                left: pageXOffset,\n                height: innerHeight,\n                width: innerWidth\n            };\n        } else {\n            const bounds = getBounds(body, target);\n            const out = {\n                height: bounds.height,\n                width: bounds.width,\n                top: bounds.top,\n                left: bounds.left\n            };\n            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\n            out.height = Math.min(innerHeight, out.height);\n            out.height -= 2;\n            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\n            out.width = Math.min(innerWidth, out.width);\n            out.width -= 2;\n            if (out.top < pageYOffset) {\n                out.top = pageYOffset;\n            }\n            if (out.left < pageXOffset) {\n                out.left = pageXOffset;\n            }\n            return out;\n        }\n    }\n    function removeUtilElements(body) {\n        if (zeroElement) {\n            body.removeChild(zeroElement);\n        }\n        zeroElement = null;\n    }\n    function _getActualBoundingClientRect(node) {\n        let boundingRect = node.getBoundingClientRect();\n        let rect = {};\n        for (let k in boundingRect) {\n            rect[k] = boundingRect[k];\n        }\n        try {\n            if (node.ownerDocument !== document) {\n                let {frameElement} = node.ownerDocument.defaultView;\n                if (frameElement) {\n                    let frameRect = _getActualBoundingClientRect(frameElement);\n                    rect.top += frameRect.top;\n                    rect.bottom += frameRect.top;\n                    rect.left += frameRect.left;\n                    rect.right += frameRect.left;\n                }\n            }\n        } catch (err) {\n        }\n        return rect;\n    }\n    function _getOrigin(body) {\n        let node = zeroElement;\n        if (!node || !body.contains(node)) {\n            node = document.createElement('div');\n            node.setAttribute('data-tether-id', general.uniqueId());\n            general.extend(node.style, {\n                top: 0,\n                left: 0,\n                position: 'absolute'\n            });\n            body.appendChild(node);\n            zeroElement = node;\n        }\n        const id = node.getAttribute('data-tether-id');\n        if (typecheck.isUndefined(zeroPosCache[id])) {\n            zeroPosCache[id] = _getActualBoundingClientRect(node);\n            deferred.defer(() => {\n                delete zeroPosCache[id];\n            });\n        }\n        return zeroPosCache[id];\n    }\n    return {\n        getBounds: getBounds,\n        getScrollHandleBounds: getScrollHandleBounds,\n        getVisibleBounds: getVisibleBounds,\n        removeUtilElements: removeUtilElements\n    };\n});\ndefine('skylark-tether/abutment',[\n    './utils/classes',\n    './utils/deferred',\n    './utils/bounds'\n], function (_classes, deferred, bounds) {\n    'use strict';\n    return {\n        position({top, left}) {\n            const {height, width} = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.element);\n            });\n            const targetPos = this.getTargetBounds();\n            const bottom = top + height;\n            const right = left + width;\n            const abutted = [];\n            if (top <= targetPos.bottom && bottom >= targetPos.top) {\n                [\n                    'left',\n                    'right'\n                ].forEach(side => {\n                    const targetPosSide = targetPos[side];\n                    if (targetPosSide === left || targetPosSide === right) {\n                        abutted.push(side);\n                    }\n                });\n            }\n            if (left <= targetPos.right && right >= targetPos.left) {\n                [\n                    'top',\n                    'bottom'\n                ].forEach(side => {\n                    const targetPosSide = targetPos[side];\n                    if (targetPosSide === top || targetPosSide === bottom) {\n                        abutted.push(side);\n                    }\n                });\n            }\n            const sides = [\n                'left',\n                'top',\n                'right',\n                'bottom'\n            ];\n            const {classes, classPrefix} = this.options;\n            this.all.push(_classes.getClass('abutted', classes, classPrefix));\n            sides.forEach(side => {\n                this.all.push(`${ _classes.getClass('abutted', classes, classPrefix) }-${ side }`);\n            });\n            if (abutted.length) {\n                this.add.push(_classes.getClass('abutted', classes, classPrefix));\n            }\n            abutted.forEach(side => {\n                this.add.push(`${ _classes.getClass('abutted', classes, classPrefix) }-${ side }`);\n            });\n            deferred.defer(() => {\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, this.add, this.all);\n                }\n                _classes.updateClasses(this.element, this.add, this.all);\n            });\n            return true;\n        }\n    };\n});\ndefine('skylark-tether/constraint',[\n    './utils/classes',\n    './utils/deferred',\n    './utils/general',\n    './utils/bounds',\n    './utils/type-check'\n], function (_classes, deferred, general, bounds, typecheck) {\n    'use strict';\n    const BOUNDS_FORMAT = [\n        'left',\n        'top',\n        'right',\n        'bottom'\n    ];\n    function getBoundingRect(body, tether, to) {\n        if (!to) {\n            return null;\n        }\n        if (to === 'scrollParent') {\n            to = tether.scrollParents[0];\n        } else if (to === 'window') {\n            to = [\n                pageXOffset,\n                pageYOffset,\n                innerWidth + pageXOffset,\n                innerHeight + pageYOffset\n            ];\n        }\n        if (to === document) {\n            to = to.documentElement;\n        }\n        if (!typecheck.isUndefined(to.nodeType)) {\n            const node = to;\n            const size = bounds.getBounds(body, to);\n            const pos = size;\n            const style = getComputedStyle(to);\n            to = [\n                pos.left,\n                pos.top,\n                size.width + pos.left,\n                size.height + pos.top\n            ];\n            if (node.ownerDocument !== document) {\n                let win = node.ownerDocument.defaultView;\n                to[0] += win.pageXOffset;\n                to[1] += win.pageYOffset;\n                to[2] += win.pageXOffset;\n                to[3] += win.pageYOffset;\n            }\n            BOUNDS_FORMAT.forEach((side, i) => {\n                side = side[0].toUpperCase() + side.substr(1);\n                if (side === 'Top' || side === 'Left') {\n                    to[i] += parseFloat(style[`border${ side }Width`]);\n                } else {\n                    to[i] -= parseFloat(style[`border${ side }Width`]);\n                }\n            });\n        }\n        return to;\n    }\n    function _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, outOfBoundsClass) {\n        if (oob.length) {\n            let oobClass;\n            if (!typecheck.isUndefined(outOfBoundsClass)) {\n                oobClass = outOfBoundsClass;\n            } else {\n                oobClass = _classes.getClass('out-of-bounds', classes, classPrefix);\n            }\n            addClasses.push(oobClass);\n            oob.forEach(side => {\n                addClasses.push(`${ oobClass }-${ side }`);\n            });\n        }\n    }\n    function _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob) {\n        if (left < bounds[0]) {\n            if (pin.indexOf('left') >= 0) {\n                left = bounds[0];\n                pinned.push('left');\n            } else {\n                oob.push('left');\n            }\n        }\n        if (left + width > bounds[2]) {\n            if (pin.indexOf('right') >= 0) {\n                left = bounds[2] - width;\n                pinned.push('right');\n            } else {\n                oob.push('right');\n            }\n        }\n        return left;\n    }\n    function _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob) {\n        if (top < bounds[1]) {\n            if (pin.indexOf('top') >= 0) {\n                top = bounds[1];\n                pinned.push('top');\n            } else {\n                oob.push('top');\n            }\n        }\n        if (top + height > bounds[3]) {\n            if (pin.indexOf('bottom') >= 0) {\n                top = bounds[3] - height;\n                pinned.push('bottom');\n            } else {\n                oob.push('bottom');\n            }\n        }\n        return top;\n    }\n    function _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left) {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n            if (eAttachment.left === 'right') {\n                left += targetWidth;\n                tAttachment.left = 'right';\n                left += width;\n                eAttachment.left = 'left';\n            } else if (eAttachment.left === 'left') {\n                left += targetWidth;\n                tAttachment.left = 'right';\n                left -= width;\n                eAttachment.left = 'right';\n            }\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n            if (eAttachment.left === 'left') {\n                left -= targetWidth;\n                tAttachment.left = 'left';\n                left -= width;\n                eAttachment.left = 'right';\n            } else if (eAttachment.left === 'right') {\n                left -= targetWidth;\n                tAttachment.left = 'left';\n                left += width;\n                eAttachment.left = 'left';\n            }\n        } else if (tAttachment.left === 'center') {\n            if (left + width > bounds[2] && eAttachment.left === 'left') {\n                left -= width;\n                eAttachment.left = 'right';\n            } else if (left < bounds[0] && eAttachment.left === 'right') {\n                left += width;\n                eAttachment.left = 'left';\n            }\n        }\n        return left;\n    }\n    function _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top) {\n        if (tAttachment.top === 'top') {\n            if (eAttachment.top === 'bottom' && top < bounds[1]) {\n                top += targetHeight;\n                tAttachment.top = 'bottom';\n                top += height;\n                eAttachment.top = 'top';\n            } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n                top -= height - targetHeight;\n                tAttachment.top = 'bottom';\n                eAttachment.top = 'bottom';\n            }\n        }\n        if (tAttachment.top === 'bottom') {\n            if (eAttachment.top === 'top' && top + height > bounds[3]) {\n                top -= targetHeight;\n                tAttachment.top = 'top';\n                top -= height;\n                eAttachment.top = 'bottom';\n            } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n                top += height - targetHeight;\n                tAttachment.top = 'top';\n                eAttachment.top = 'top';\n            }\n        }\n        if (tAttachment.top === 'middle') {\n            if (top + height > bounds[3] && eAttachment.top === 'top') {\n                top -= height;\n                eAttachment.top = 'bottom';\n            } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n                top += height;\n                eAttachment.top = 'top';\n            }\n        }\n        return top;\n    }\n    function _getAllClasses(classes, classPrefix, constraints) {\n        const allClasses = [\n            _classes.getClass('pinned', classes, classPrefix),\n            _classes.getClass('out-of-bounds', classes, classPrefix)\n        ];\n        constraints.forEach(constraint => {\n            const {outOfBoundsClass, pinnedClass} = constraint;\n            if (outOfBoundsClass) {\n                allClasses.push(outOfBoundsClass);\n            }\n            if (pinnedClass) {\n                allClasses.push(pinnedClass);\n            }\n        });\n        allClasses.forEach(cls => {\n            [\n                'left',\n                'top',\n                'right',\n                'bottom'\n            ].forEach(side => {\n                allClasses.push(`${ cls }-${ side }`);\n            });\n        });\n        return allClasses;\n    }\n    return {\n        position({top, left, targetAttachment}) {\n            if (!this.options.constraints) {\n                return true;\n            }\n            let {height, width} = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.bodyElement, this.element);\n            });\n            if (width === 0 && height === 0 && !typecheck.isUndefined(this.lastSize)) {\n                ({width, height} = this.lastSize);\n            }\n            const targetSize = this.cache('target-bounds', () => {\n                return this.getTargetBounds();\n            });\n            const {\n                height: targetHeight,\n                width: targetWidth\n            } = targetSize;\n            const {classes, classPrefix} = this.options;\n            const allClasses = _getAllClasses(classes, classPrefix, this.options.constraints);\n            const addClasses = [];\n            const tAttachment = general.extend({}, targetAttachment);\n            const eAttachment = general.extend({}, this.attachment);\n            this.options.constraints.forEach(constraint => {\n                let {to, attachment, pin} = constraint;\n                if (typecheck.isUndefined(attachment)) {\n                    attachment = '';\n                }\n                let changeAttachX, changeAttachY;\n                if (attachment.indexOf(' ') >= 0) {\n                    [changeAttachY, changeAttachX] = attachment.split(' ');\n                } else {\n                    changeAttachX = changeAttachY = attachment;\n                }\n                const bounds = getBoundingRect(this.bodyElement, this, to);\n                if (changeAttachY === 'target' || changeAttachY === 'both') {\n                    if (top < bounds[1] && tAttachment.top === 'top') {\n                        top += targetHeight;\n                        tAttachment.top = 'bottom';\n                    }\n                    if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n                        top -= targetHeight;\n                        tAttachment.top = 'top';\n                    }\n                }\n                if (changeAttachY === 'together') {\n                    top = _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top);\n                }\n                if (changeAttachX === 'target' || changeAttachX === 'both') {\n                    if (left < bounds[0] && tAttachment.left === 'left') {\n                        left += targetWidth;\n                        tAttachment.left = 'right';\n                    }\n                    if (left + width > bounds[2] && tAttachment.left === 'right') {\n                        left -= targetWidth;\n                        tAttachment.left = 'left';\n                    }\n                }\n                if (changeAttachX === 'together') {\n                    left = _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left);\n                }\n                if (changeAttachY === 'element' || changeAttachY === 'both') {\n                    if (top < bounds[1] && eAttachment.top === 'bottom') {\n                        top += height;\n                        eAttachment.top = 'top';\n                    }\n                    if (top + height > bounds[3] && eAttachment.top === 'top') {\n                        top -= height;\n                        eAttachment.top = 'bottom';\n                    }\n                }\n                if (changeAttachX === 'element' || changeAttachX === 'both') {\n                    if (left < bounds[0]) {\n                        if (eAttachment.left === 'right') {\n                            left += width;\n                            eAttachment.left = 'left';\n                        } else if (eAttachment.left === 'center') {\n                            left += width / 2;\n                            eAttachment.left = 'left';\n                        }\n                    }\n                    if (left + width > bounds[2]) {\n                        if (eAttachment.left === 'left') {\n                            left -= width;\n                            eAttachment.left = 'right';\n                        } else if (eAttachment.left === 'center') {\n                            left -= width / 2;\n                            eAttachment.left = 'right';\n                        }\n                    }\n                }\n                if (typecheck.isString(pin)) {\n                    pin = pin.split(',').map(p => p.trim());\n                } else if (pin === true) {\n                    pin = [\n                        'top',\n                        'left',\n                        'right',\n                        'bottom'\n                    ];\n                }\n                pin = pin || [];\n                const pinned = [];\n                const oob = [];\n                left = _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob);\n                top = _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob);\n                if (pinned.length) {\n                    let pinnedClass;\n                    if (!typecheck.isUndefined(this.options.pinnedClass)) {\n                        pinnedClass = this.options.pinnedClass;\n                    } else {\n                        pinnedClass = _classes.getClass('pinned', classes, classPrefix);\n                    }\n                    addClasses.push(pinnedClass);\n                    pinned.forEach(side => {\n                        addClasses.push(`${ pinnedClass }-${ side }`);\n                    });\n                }\n                _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, this.options.outOfBoundsClass);\n                if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n                    eAttachment.left = tAttachment.left = false;\n                }\n                if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n                    eAttachment.top = tAttachment.top = false;\n                }\n                if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== this.attachment.top || eAttachment.left !== this.attachment.left) {\n                    this.updateAttachClasses(eAttachment, tAttachment);\n                    this.trigger('update', {\n                        attachment: eAttachment,\n                        targetAttachment: tAttachment\n                    });\n                }\n            });\n            deferred.defer(() => {\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, addClasses, allClasses);\n                }\n                _classes.updateClasses(this.element, addClasses, allClasses);\n            });\n            return {\n                top,\n                left\n            };\n        }\n    };\n});\ndefine('skylark-tether/shift',['./utils/type-check'], function (typecheck) {\n    'use strict';\n    return {\n        position({top, left}) {\n            if (!this.options.shift) {\n                return;\n            }\n            let {shift} = this.options;\n            if (typecheck.isFunction(shift)) {\n                shift = shift.call(this, {\n                    top,\n                    left\n                });\n            }\n            let shiftTop, shiftLeft;\n            if (typecheck.isString(shift)) {\n                shift = shift.split(' ');\n                shift[1] = shift[1] || shift[0];\n                [shiftTop, shiftLeft] = shift;\n                shiftTop = parseFloat(shiftTop, 10);\n                shiftLeft = parseFloat(shiftLeft, 10);\n            } else {\n                [shiftTop, shiftLeft] = [\n                    shift.top,\n                    shift.left\n                ];\n            }\n            top += shiftTop;\n            left += shiftLeft;\n            return {\n                top,\n                left\n            };\n        }\n    };\n});\ndefine('skylark-tether/evented',['./utils/type-check'], function (typecheck) {\n    'use strict';\n    class Evented {\n        on(event, handler, ctx, once = false) {\n            if (typecheck.isUndefined(this.bindings)) {\n                this.bindings = {};\n            }\n            if (typecheck.isUndefined(this.bindings[event])) {\n                this.bindings[event] = [];\n            }\n            this.bindings[event].push({\n                handler,\n                ctx,\n                once\n            });\n            return this;\n        }\n        once(event, handler, ctx) {\n            return this.on(event, handler, ctx, true);\n        }\n        off(event, handler) {\n            if (typecheck.isUndefined(this.bindings) || typecheck.isUndefined(this.bindings[event])) {\n                return this;\n            }\n            if (typecheck.isUndefined(handler)) {\n                delete this.bindings[event];\n            } else {\n                this.bindings[event].forEach((binding, index) => {\n                    if (binding.handler === handler) {\n                        this.bindings[event].splice(index, 1);\n                    }\n                });\n            }\n            return this;\n        }\n        trigger(event, ...args) {\n            if (!typecheck.isUndefined(this.bindings) && this.bindings[event]) {\n                this.bindings[event].forEach((binding, index) => {\n                    const {ctx, handler, once} = binding;\n                    const context = ctx || this;\n                    handler.apply(context, args);\n                    if (once) {\n                        this.bindings[event].splice(index, 1);\n                    }\n                });\n            }\n            return this;\n        }\n    }\n    return { Evented: Evented };\n});\ndefine('skylark-tether/utils/offset',['./type-check'], function (typecheck) {\n    'use strict';\n    const MIRROR_LR = {\n        center: 'center',\n        left: 'right',\n        right: 'left'\n    };\n    const MIRROR_TB = {\n        middle: 'middle',\n        top: 'bottom',\n        bottom: 'top'\n    };\n    const OFFSET_MAP = {\n        top: 0,\n        left: 0,\n        middle: '50%',\n        center: '50%',\n        bottom: '100%',\n        right: '100%'\n    };\n    function addOffset(...offsets) {\n        const out = {\n            top: 0,\n            left: 0\n        };\n        offsets.forEach(({top, left}) => {\n            if (typecheck.isString(top)) {\n                top = parseFloat(top);\n            }\n            if (typecheck.isString(left)) {\n                left = parseFloat(left);\n            }\n            out.top += top;\n            out.left += left;\n        });\n        return out;\n    }\n    function attachmentToOffset(attachment) {\n        let {left, top} = attachment;\n        if (!typecheck.isUndefined(OFFSET_MAP[attachment.left])) {\n            left = OFFSET_MAP[attachment.left];\n        }\n        if (!typecheck.isUndefined(OFFSET_MAP[attachment.top])) {\n            top = OFFSET_MAP[attachment.top];\n        }\n        return {\n            left,\n            top\n        };\n    }\n    function autoToFixedAttachment(attachment, relativeToAttachment) {\n        let {left, top} = attachment;\n        if (left === 'auto') {\n            left = MIRROR_LR[relativeToAttachment.left];\n        }\n        if (top === 'auto') {\n            top = MIRROR_TB[relativeToAttachment.top];\n        }\n        return {\n            left,\n            top\n        };\n    }\n    function offsetToPx(offset, size) {\n        if (typecheck.isString(offset.left) && offset.left.indexOf('%') !== -1) {\n            offset.left = parseFloat(offset.left) / 100 * size.width;\n        }\n        if (typecheck.isString(offset.top) && offset.top.indexOf('%') !== -1) {\n            offset.top = parseFloat(offset.top) / 100 * size.height;\n        }\n        return offset;\n    }\n    function parseTopLeft(value) {\n        const [top, left] = value.split(' ');\n        return {\n            top,\n            left\n        };\n    }\n    return {\n        addOffset: addOffset,\n        attachmentToOffset: attachmentToOffset,\n        autoToFixedAttachment: autoToFixedAttachment,\n        offsetToPx: offsetToPx,\n        parseTopLeft: parseTopLeft\n    };\n});\ndefine('skylark-tether/utils/parents',['./type-check'], function (typecheck) {\n    'use strict';\n    function getScrollParents(el) {\n        const computedStyle = getComputedStyle(el) || {};\n        const {position} = computedStyle;\n        let parents = [];\n        if (position === 'fixed') {\n            return [el];\n        }\n        let parent = el;\n        while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n            let style;\n            try {\n                style = getComputedStyle(parent);\n            } catch (err) {\n            }\n            if (typecheck.isUndefined(style) || style === null) {\n                parents.push(parent);\n                return parents;\n            }\n            const {overflow, overflowX, overflowY} = style;\n            if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n                if (position !== 'absolute' || [\n                        'relative',\n                        'absolute',\n                        'fixed'\n                    ].indexOf(style.position) >= 0) {\n                    parents.push(parent);\n                }\n            }\n        }\n        parents.push(el.ownerDocument.body);\n        if (el.ownerDocument !== document) {\n            parents.push(el.ownerDocument.defaultView);\n        }\n        return parents;\n    }\n    function getOffsetParent(el) {\n        return el.offsetParent || document.documentElement;\n    }\n    return {\n        getScrollParents: getScrollParents,\n        getOffsetParent: getOffsetParent\n    };\n});\ndefine('skylark-tether/Tether',[\n    \"skylark-langx/skylark\",\n    './abutment',\n    './constraint',\n    './shift',\n    './evented',\n    './utils/classes',\n    './utils/deferred',\n    './utils/general',\n    './utils/offset',\n    './utils/bounds',\n    './utils/parents',\n    './utils/type-check'\n], function (skylark,Abutment, Constraint, Shift, evented, _classes, deferred, general, _offset, bounds, parents, typecheck) {\n    'use strict';\n    const TetherBase = {\n        modules: [\n            Constraint,\n            Abutment,\n            Shift\n        ]\n    };\n    function isFullscreenElement(e) {\n        let d = e.ownerDocument;\n        let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n        return fe === e;\n    }\n    function within(a, b, diff = 1) {\n        return a + diff >= b && b >= a - diff;\n    }\n    const transformKey = (() => {\n        if (typecheck.isUndefined(document)) {\n            return '';\n        }\n        const el = document.createElement('div');\n        const transforms = [\n            'transform',\n            'WebkitTransform',\n            'OTransform',\n            'MozTransform',\n            'msTransform'\n        ];\n        for (let i = 0; i < transforms.length; ++i) {\n            const key = transforms[i];\n            if (el.style[key] !== undefined) {\n                return key;\n            }\n        }\n    })();\n    const tethers = [];\n    const position = () => {\n        tethers.forEach(tether => {\n            tether.position(false);\n        });\n        deferred.flush();\n    };\n    function now() {\n        return performance.now();\n    }\n    (() => {\n        let lastCall = null;\n        let lastDuration = null;\n        let pendingTimeout = null;\n        const tick = () => {\n            if (!typecheck.isUndefined(lastDuration) && lastDuration > 16) {\n                lastDuration = Math.min(lastDuration - 16, 250);\n                pendingTimeout = setTimeout(tick, 250);\n                return;\n            }\n            if (!typecheck.isUndefined(lastCall) && now() - lastCall < 10) {\n                return;\n            }\n            if (pendingTimeout != null) {\n                clearTimeout(pendingTimeout);\n                pendingTimeout = null;\n            }\n            lastCall = now();\n            position();\n            lastDuration = now() - lastCall;\n        };\n        if (!typecheck.isUndefined(window) && !typecheck.isUndefined(window.addEventListener)) {\n            [\n                'resize',\n                'scroll',\n                'touchmove'\n            ].forEach(event => {\n                window.addEventListener(event, tick);\n            });\n        }\n    })();\n    class TetherClass extends evented.Evented {\n        constructor(options) {\n            super();\n            this.position = this.position.bind(this);\n            tethers.push(this);\n            this.history = [];\n            this.setOptions(options, false);\n            TetherBase.modules.forEach(module => {\n                if (!typecheck.isUndefined(module.initialize)) {\n                    module.initialize.call(this);\n                }\n            });\n            this.position();\n        }\n        setOptions(options, pos = true) {\n            const defaults = {\n                offset: '0 0',\n                targetOffset: '0 0',\n                targetAttachment: 'auto auto',\n                classPrefix: 'tether',\n                bodyElement: document.body\n            };\n            this.options = general.extend(defaults, options);\n            let {element, target, targetModifier, bodyElement} = this.options;\n            this.element = element;\n            this.target = target;\n            this.targetModifier = targetModifier;\n            if (typeof bodyElement === 'string') {\n                bodyElement = document.querySelector(bodyElement);\n            }\n            this.bodyElement = bodyElement;\n            if (this.target === 'viewport') {\n                this.target = document.body;\n                this.targetModifier = 'visible';\n            } else if (this.target === 'scroll-handle') {\n                this.target = document.body;\n                this.targetModifier = 'scroll-handle';\n            }\n            [\n                'element',\n                'target'\n            ].forEach(key => {\n                if (typecheck.isUndefined(this[key])) {\n                    throw new Error('Tether Error: Both element and target must be defined');\n                }\n                if (!typecheck.isUndefined(this[key].jquery)) {\n                    this[key] = this[key][0];\n                } else if (typecheck.isString(this[key])) {\n                    this[key] = document.querySelector(this[key]);\n                }\n            });\n            this._addClasses();\n            if (!this.options.attachment) {\n                throw new Error('Tether Error: You must provide an attachment');\n            }\n            this.targetAttachment = _offset.parseTopLeft(this.options.targetAttachment);\n            this.attachment = _offset.parseTopLeft(this.options.attachment);\n            this.offset = _offset.parseTopLeft(this.options.offset);\n            this.targetOffset = _offset.parseTopLeft(this.options.targetOffset);\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.disable();\n            }\n            if (this.targetModifier === 'scroll-handle') {\n                this.scrollParents = [this.target];\n            } else {\n                this.scrollParents = parents.getScrollParents(this.target);\n            }\n            if (!(this.options.enabled === false)) {\n                this.enable(pos);\n            }\n        }\n        getTargetBounds() {\n            if (!typecheck.isUndefined(this.targetModifier)) {\n                if (this.targetModifier === 'visible') {\n                    return bounds.getVisibleBounds(this.bodyElement, this.target);\n                } else if (this.targetModifier === 'scroll-handle') {\n                    return bounds.getScrollHandleBounds(this.bodyElement, this.target);\n                }\n            } else {\n                return bounds.getBounds(this.bodyElement, this.target);\n            }\n        }\n        clearCache() {\n            this._cache = {};\n        }\n        cache(k, getter) {\n            if (typecheck.isUndefined(this._cache)) {\n                this._cache = {};\n            }\n            if (typecheck.isUndefined(this._cache[k])) {\n                this._cache[k] = getter.call(this);\n            }\n            return this._cache[k];\n        }\n        enable(pos = true) {\n            const {classes, classPrefix} = this.options;\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            }\n            _classes.addClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = true;\n            this.scrollParents.forEach(parent => {\n                if (parent !== this.target.ownerDocument) {\n                    parent.addEventListener('scroll', this.position);\n                }\n            });\n            if (pos) {\n                this.position();\n            }\n        }\n        disable() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.target, _classes.getClass('enabled', classes, classPrefix));\n            _classes.removeClass(this.element, _classes.getClass('enabled', classes, classPrefix));\n            this.enabled = false;\n            if (!typecheck.isUndefined(this.scrollParents)) {\n                this.scrollParents.forEach(parent => {\n                    parent.removeEventListener('scroll', this.position);\n                });\n            }\n        }\n        destroy() {\n            this.disable();\n            this._removeClasses();\n            tethers.forEach((tether, i) => {\n                if (tether === this) {\n                    tethers.splice(i, 1);\n                }\n            });\n            if (tethers.length === 0) {\n                bounds.removeUtilElements(this.bodyElement);\n            }\n        }\n        updateAttachClasses(elementAttach, targetAttach) {\n            elementAttach = elementAttach || this.attachment;\n            targetAttach = targetAttach || this.targetAttachment;\n            const sides = [\n                'left',\n                'top',\n                'bottom',\n                'right',\n                'middle',\n                'center'\n            ];\n            const {classes, classPrefix} = this.options;\n            if (!typecheck.isUndefined(this._addAttachClasses) && this._addAttachClasses.length) {\n                this._addAttachClasses.splice(0, this._addAttachClasses.length);\n            }\n            if (typecheck.isUndefined(this._addAttachClasses)) {\n                this._addAttachClasses = [];\n            }\n            this.add = this._addAttachClasses;\n            if (elementAttach.top) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.top }`);\n            }\n            if (elementAttach.left) {\n                this.add.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ elementAttach.left }`);\n            }\n            if (targetAttach.top) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.top }`);\n            }\n            if (targetAttach.left) {\n                this.add.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ targetAttach.left }`);\n            }\n            this.all = [];\n            sides.forEach(side => {\n                this.all.push(`${ _classes.getClass('element-attached', classes, classPrefix) }-${ side }`);\n                this.all.push(`${ _classes.getClass('target-attached', classes, classPrefix) }-${ side }`);\n            });\n            deferred.defer(() => {\n                if (typecheck.isUndefined(this._addAttachClasses)) {\n                    return;\n                }\n                _classes.updateClasses(this.element, this._addAttachClasses, this.all);\n                if (!(this.options.addTargetClasses === false)) {\n                    _classes.updateClasses(this.target, this._addAttachClasses, this.all);\n                }\n                delete this._addAttachClasses;\n            });\n        }\n        position(flushChanges = true) {\n            if (!this.enabled) {\n                return;\n            }\n            this.clearCache();\n            const targetAttachment = _offset.autoToFixedAttachment(this.targetAttachment, this.attachment);\n            this.updateAttachClasses(this.attachment, targetAttachment);\n            const elementPos = this.cache('element-bounds', () => {\n                return bounds.getBounds(this.bodyElement, this.element);\n            });\n            let {width, height} = elementPos;\n            if (width === 0 && height === 0 && !typecheck.isUndefined(this.lastSize)) {\n                ({width, height} = this.lastSize);\n            } else {\n                this.lastSize = {\n                    width,\n                    height\n                };\n            }\n            const targetPos = this.cache('target-bounds', () => {\n                return this.getTargetBounds();\n            });\n            const targetSize = targetPos;\n            let offset = _offset.offsetToPx(_offset.attachmentToOffset(this.attachment), {\n                width,\n                height\n            });\n            let targetOffset = _offset.offsetToPx(_offset.attachmentToOffset(targetAttachment), targetSize);\n            const manualOffset = _offset.offsetToPx(this.offset, {\n                width,\n                height\n            });\n            const manualTargetOffset = _offset.offsetToPx(this.targetOffset, targetSize);\n            offset = _offset.addOffset(offset, manualOffset);\n            targetOffset = _offset.addOffset(targetOffset, manualTargetOffset);\n            let left = targetPos.left + targetOffset.left - offset.left;\n            let top = targetPos.top + targetOffset.top - offset.top;\n\n\n            let scrollbarSize;\n\n            for (let i = 0; i < TetherBase.modules.length; ++i) {\n                const module = TetherBase.modules[i];\n                const ret = module.position.call(this, {\n                    left,\n                    top,\n                    targetAttachment,\n                    targetPos,\n                    elementPos,\n                    offset,\n                    targetOffset,\n                    manualOffset,\n                    manualTargetOffset,\n                    scrollbarSize,\n                    attachment: this.attachment\n                });\n                if (ret === false) {\n                    return false;\n                } else if (typecheck.isUndefined(ret) || !typecheck.isObject(ret)) {\n                    continue;\n                } else {\n                    ({top, left} = ret);\n                }\n            }\n            const next = {\n                page: {\n                    top,\n                    left\n                },\n                viewport: {\n                    top: top - pageYOffset,\n                    bottom: pageYOffset - top - height + innerHeight,\n                    left: left - pageXOffset,\n                    right: pageXOffset - left - width + innerWidth\n                }\n            };\n            let doc = this.target.ownerDocument;\n            let win = doc.defaultView;\n            if (win.innerHeight > doc.documentElement.clientHeight) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.bottom -= scrollbarSize.height;\n            }\n            if (win.innerWidth > doc.documentElement.clientWidth) {\n                scrollbarSize = this.cache('scrollbar-size', general.getScrollBarSize);\n                next.viewport.right -= scrollbarSize.width;\n            }\n            if ([\n                    '',\n                    'static'\n                ].indexOf(doc.body.style.position) === -1 || [\n                    '',\n                    'static'\n                ].indexOf(doc.body.parentElement.style.position) === -1) {\n                next.page.bottom = doc.body.scrollHeight - top - height;\n                next.page.right = doc.body.scrollWidth - left - width;\n            }\n            if (!typecheck.isUndefined(this.options.optimizations) && this.options.optimizations.moveElement !== false && typecheck.isUndefined(this.targetModifier)) {\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                const offsetPosition = this.cache('target-offsetparent-bounds', () => bounds.getBounds(this.bodyElement, offsetParent));\n                const offsetParentStyle = getComputedStyle(offsetParent);\n                const offsetParentSize = offsetPosition;\n                const offsetBorder = {};\n                [\n                    'Top',\n                    'Left',\n                    'Bottom',\n                    'Right'\n                ].forEach(side => {\n                    offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${ side }Width`]);\n                });\n                offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n                offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n                if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\n                    if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\n                        const {scrollLeft, scrollTop} = offsetParent;\n                        next.offset = {\n                            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n                            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n                        };\n                    }\n                }\n            }\n            this.move(next);\n            this.history.unshift(next);\n            if (this.history.length > 3) {\n                this.history.pop();\n            }\n            if (flushChanges) {\n                deferred.flush();\n            }\n            return true;\n        }\n        move(pos) {\n            if (typecheck.isUndefined(this.element.parentNode)) {\n                return;\n            }\n            const same = {};\n            for (let type in pos) {\n                same[type] = {};\n                for (let key in pos[type]) {\n                    let found = false;\n                    for (let i = 0; i < this.history.length; ++i) {\n                        const point = this.history[i];\n                        if (!typecheck.isUndefined(point[type]) && !within(point[type][key], pos[type][key])) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        same[type][key] = true;\n                    }\n                }\n            }\n            let css = {\n                top: '',\n                left: '',\n                right: '',\n                bottom: ''\n            };\n            const transcribe = (_same, _pos) => {\n                const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n                const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n                if (gpu !== false) {\n                    let yPos, xPos;\n                    if (_same.top) {\n                        css.top = 0;\n                        yPos = _pos.top;\n                    } else {\n                        css.bottom = 0;\n                        yPos = -_pos.bottom;\n                    }\n                    if (_same.left) {\n                        css.left = 0;\n                        xPos = _pos.left;\n                    } else {\n                        css.right = 0;\n                        xPos = -_pos.right;\n                    }\n                    if (typecheck.isNumber(window.devicePixelRatio) && devicePixelRatio % 1 === 0) {\n                        xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n                        yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n                    }\n                    css[transformKey] = `translateX(${ xPos }px) translateY(${ yPos }px)`;\n                    if (transformKey !== 'msTransform') {\n                        css[transformKey] += ' translateZ(0)';\n                    }\n                } else {\n                    if (_same.top) {\n                        css.top = `${ _pos.top }px`;\n                    } else {\n                        css.bottom = `${ _pos.bottom }px`;\n                    }\n                    if (_same.left) {\n                        css.left = `${ _pos.left }px`;\n                    } else {\n                        css.right = `${ _pos.right }px`;\n                    }\n                }\n            };\n            const hasOptimizations = !typecheck.isUndefined(this.options.optimizations);\n            let allowPositionFixed = true;\n            if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n                allowPositionFixed = false;\n            }\n            let moved = false;\n            if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n                css.position = 'absolute';\n                transcribe(same.page, pos.page);\n            } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n                css.position = 'fixed';\n                transcribe(same.viewport, pos.viewport);\n            } else if (!typecheck.isUndefined(same.offset) && same.offset.top && same.offset.left) {\n                css.position = 'absolute';\n                const offsetParent = this.cache('target-offsetparent', () => parents.getOffsetParent(this.target));\n                if (parents.getOffsetParent(this.element) !== offsetParent) {\n                    deferred.defer(() => {\n                        this.element.parentNode.removeChild(this.element);\n                        offsetParent.appendChild(this.element);\n                    });\n                }\n                transcribe(same.offset, pos.offset);\n                moved = true;\n            } else {\n                css.position = 'absolute';\n                transcribe({\n                    top: true,\n                    left: true\n                }, pos.page);\n            }\n            if (!moved) {\n                if (this.options.bodyElement) {\n                    if (this.element.parentNode !== this.options.bodyElement) {\n                        this.options.bodyElement.appendChild(this.element);\n                    }\n                } else {\n                    let offsetParentIsBody = true;\n                    let currentNode = this.element.parentNode;\n                    while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n                        if (getComputedStyle(currentNode).position !== 'static') {\n                            offsetParentIsBody = false;\n                            break;\n                        }\n                        currentNode = currentNode.parentNode;\n                    }\n                    if (!offsetParentIsBody) {\n                        this.element.parentNode.removeChild(this.element);\n                        this.element.ownerDocument.body.appendChild(this.element);\n                    }\n                }\n            }\n            const writeCSS = {};\n            let write = false;\n            for (let key in css) {\n                let val = css[key];\n                let elVal = this.element.style[key];\n                if (elVal !== val) {\n                    write = true;\n                    writeCSS[key] = val;\n                }\n            }\n            if (write) {\n                deferred.defer(() => {\n                    general.extend(this.element.style, writeCSS);\n                    this.trigger('repositioned');\n                });\n            }\n        }\n        _addClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.addClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.addClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n        }\n        _removeClasses() {\n            const {classes, classPrefix} = this.options;\n            _classes.removeClass(this.element, _classes.getClass('element', classes, classPrefix));\n            if (!(this.options.addTargetClasses === false)) {\n                _classes.removeClass(this.target, _classes.getClass('target', classes, classPrefix));\n            }\n            this.all.forEach(className => {\n                this.element.classList.remove(className);\n                this.target.classList.remove(className);\n            });\n        }\n    }\n    TetherClass.modules = [];\n    TetherBase.position = position;\n    let Tether = general.extend(TetherClass, TetherBase);\n    Tether.modules.push({\n        initialize() {\n            const {classes, classPrefix} = this.options;\n            this.markers = {};\n            [\n                'target',\n                'element'\n            ].forEach(type => {\n                const el = document.createElement('div');\n                el.className = _classes.getClass(`${ type }-marker`, classes, classPrefix);\n                const dot = document.createElement('div');\n                dot.className = _classes.getClass('marker-dot', classes, classPrefix);\n                el.appendChild(dot);\n                this[type].appendChild(el);\n                this.markers[type] = {\n                    dot,\n                    el\n                };\n            });\n        },\n        position({manualOffset, manualTargetOffset}) {\n            const offsets = {\n                element: manualOffset,\n                target: manualTargetOffset\n            };\n            for (let type in offsets) {\n                const offset = offsets[type];\n                for (let side in offset) {\n                    let val = offset[side];\n                    if (!typecheck.isString(val) || val.indexOf('%') === -1 && val.indexOf('px') === -1) {\n                        val += 'px';\n                    }\n                    if (this.markers[type].dot.style[side] !== val) {\n                        this.markers[type].dot.style[side] = val;\n                    }\n                }\n            }\n            return true;\n        }\n    });\n    return skylark.attach(\"intg.Tether\", Tether);\n});\ndefine('skylark-tether/main',[\"./Tether\"],function(Tether){\r\n\treturn Tether;\r\n});\ndefine('skylark-tether', ['skylark-tether/main'], function (main) { return main; });\n\n"]}